<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>在ubuntu上部署Kubernetes管理docker集群示例 | Sean&#39;s Note</title>
<meta name="keywords" content="docker, linux, kubernetes">
<meta name="description" content="本文通过实际操作来演示Kubernetes的使用，因为环境有限，集群部署在本地3个ubuntu上，主要包括如下内容：

部署环境介绍，以及Kubernetes集群逻辑架构
安装部署Open vSwitch跨机器容器通信工具
安装部署Etcd和Kubernetes的各大组件
演示Kubernetes管理容器和服务

关于 Kubernetes 系统架构及组件介绍见这里。">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/2015/02/docker-kubernetes-deploy2/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8a19d6c7d40c68078a482516c7c2a326ccb9f6e9282cabe7240ecc1a80c6cb47.css" integrity="sha256-ihnWx9QMaAeKSCUWx8KjJsy59ukoLKvnJA7MGoDGy0c=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/img/logo.gif">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/img/logo.gif">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/img/logo.gif">
<link rel="apple-touch-icon" href="http://localhost:1313/logo.gif">
<link rel="mask-icon" href="http://localhost:1313/logo.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/2015/02/docker-kubernetes-deploy2/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Sean&#39;s Note (Alt + H)">Sean&#39;s Note</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      在ubuntu上部署Kubernetes管理docker集群示例
    </h1>
    <div class="post-meta"><span title='2015-02-07 13:21:25 +0000 UTC'>2015-02-07</span>&nbsp;·&nbsp;14 min

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#1-%e9%83%a8%e7%bd%b2%e7%8e%af%e5%a2%83%e5%8f%8a%e6%9e%b6%e6%9e%84" aria-label="1. 部署环境及架构">1. 部署环境及架构</a></li>
                    <li>
                        <a href="#2-%e5%ae%89%e8%a3%85open-vswitch%e5%8f%8a%e9%85%8d%e7%bd%aegre" aria-label="2. 安装Open vSwitch及配置GRE">2. 安装Open vSwitch及配置GRE</a></li>
                    <li>
                        <a href="#3-%e5%ae%89%e8%a3%85kubernetes-apiserver" aria-label="3. 安装Kubernetes APIServer">3. 安装Kubernetes APIServer</a><ul>
                            
                    <li>
                        <a href="#31-%e4%b8%8b%e8%bd%bd%e5%ae%89%e8%a3%85kubernetes%e5%90%84%e7%bb%84%e4%bb%b6" aria-label="3.1 下载安装kubernetes各组件">3.1 下载安装kubernetes各组件</a></li>
                    <li>
                        <a href="#32-%e8%a7%a3%e5%8e%8b%e5%ae%89%e8%a3%85etcd" aria-label="3.2 解压安装etcd">3.2 解压安装etcd</a></li>
                    <li>
                        <a href="#33-%e9%85%8d%e7%bd%aekube-apiserver%e7%ad%89%e4%b8%baupstart%e8%84%9a%e6%9c%ac%e5%90%af%e5%8a%a8" aria-label="3.3 配置kube-apiserver等为upstart脚本启动">3.3 配置kube-apiserver等为upstart脚本启动</a></li>
                    <li>
                        <a href="#34-%e5%90%af%e5%8a%a8" aria-label="3.4 启动">3.4 启动</a></li></ul>
                    </li>
                    <li>
                        <a href="#4-%e4%bd%bf%e7%94%a8kubecfg%e9%83%a8%e7%bd%b2%e6%b5%8b%e8%af%95%e5%ba%94%e7%94%a8" aria-label="4. 使用kubecfg部署测试应用">4. 使用kubecfg部署测试应用</a><ul>
                            
                    <li>
                        <a href="#41-%e5%88%9b%e5%bb%baredis-master-pod%e5%92%8credis-master%e6%9c%8d%e5%8a%a1" aria-label="4.1 创建redis-master Pod和redis-master服务">4.1 创建redis-master Pod和redis-master服务</a></li>
                    <li>
                        <a href="#42-%e5%88%9b%e5%bb%baredis-slave-pod%e5%92%8credis-slave%e6%9c%8d%e5%8a%a1" aria-label="4.2 创建redis-slave Pod和redis-slave服务">4.2 创建redis-slave Pod和redis-slave服务</a></li>
                    <li>
                        <a href="#43-%e5%88%9b%e5%bb%bafrontend-pod%e5%92%8cfrontend%e6%9c%8d%e5%8a%a1" aria-label="4.3 创建Frontend Pod和Frontend服务">4.3 创建Frontend Pod和Frontend服务</a></li>
                    <li>
                        <a href="#44-%e5%85%b6%e4%bb%96%e6%93%8d%e4%bd%9c%e6%9b%b4%e6%96%b0%e5%88%a0%e9%99%a4%e6%9f%a5%e7%9c%8b" aria-label="4.4 其他操作（更新、删除、查看）">4.4 其他操作（更新、删除、查看）</a></li>
                    <li>
                        <a href="#45-%e6%bc%94%e7%a4%baguestbook" aria-label="4.5 演示guestbook">4.5 演示guestbook</a></li>
                    <li>
                        <a href="#46-%e6%8e%92%e9%94%99%e6%8f%90%e7%a4%ba" aria-label="4.6 排错提示">4.6 排错提示</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>


  <div class="post-content"><p>本文通过实际操作来演示Kubernetes的使用，因为环境有限，集群部署在本地3个ubuntu上，主要包括如下内容：</p>
<ul>
<li>部署环境介绍，以及Kubernetes集群逻辑架构</li>
<li>安装部署Open vSwitch跨机器容器通信工具</li>
<li>安装部署Etcd和Kubernetes的各大组件</li>
<li>演示Kubernetes管理容器和服务</li>
</ul>
<p>关于 Kubernetes 系统架构及组件介绍见<a href="http://xgknight.com/2015/02/03/docker-kubernetes-arch-introduction/">这里</a>。</p>
<h1 id="1-部署环境及架构">1. 部署环境及架构<a hidden class="anchor" aria-hidden="true" href="#1-部署环境及架构">#</a></h1>
<ul>
<li>vSphere: 5.1</li>
<li>操作系统: ubuntu 14.04 x86_64</li>
<li>Open vSwith版本: 2.0.2</li>
<li>Kubernetes: v0.7.2</li>
<li>Etcd版本: 2.0.0-rc.1</li>
<li>Docker版本: 1.4.1</li>
<li>服务器信息：</li>
</ul>
<table>
  <thead>
      <tr>
          <th>Role</th>
          <th>Hostname</th>
          <th>IP Address</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>APIServer</td>
          <td>kubernetes</td>
          <td>172.29.88.206</td>
      </tr>
      <tr>
          <td>Minion</td>
          <td>minion1</td>
          <td>172.29.88.207</td>
      </tr>
      <tr>
          <td>Minion</td>
          <td>minion2</td>
          <td>172.29.88.208</td>
      </tr>
  </tbody>
</table>
<p>在详细介绍部署Kubernetes集群前，先给大家展示下集群的逻辑架构。从下图可知，整个系统分为两部分，第一部分是Kubernetes APIServer，是整个系统的核心，承担集群中所有容器的管理工作；第二部分是minion，运行Container Daemon，是所有容器栖息之地，同时在minion上运行Open vSwitch程序，通过GRE Tunnel负责minions之间Pod的网络通信工作。
<img alt="kubernetes-deploy" loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/kubernetes-deploy.png"></p>
<h1 id="2-安装open-vswitch及配置gre">2. 安装Open vSwitch及配置GRE<a hidden class="anchor" aria-hidden="true" href="#2-安装open-vswitch及配置gre">#</a></h1>
<p>为了解决跨minion之间Pod的通信问题，我们在每个minion上安装Open vSwtich，并使用GRE或者VxLAN使得跨机器之间P11od能相互通信，本文使用GRE，而VxLAN通常用在需要隔离的大规模网络中。对于Open vSwitch的介绍请参考另一篇文章<a href="http://">Open vSwitch</a>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">sudo apt-get install openvswitch-switch bridge-utils
</span></span></code></pre></td></tr></table>
</div>
</div><p>安装完Open vSwitch和桥接工具后，接下来便建立minion0和minion1之间的隧道。首先在minion1和minion2上分别建立OVS Bridge：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># ovs-vsctl add-br obr0
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来建立gre，并将新建的gre0添加到obr0，在minion1上执行如下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># ovs-vsctl add-port obr0 gre0 -- set Interface gre0 type=gre options:remote_ip=172.29.88.208
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的remoute_ip是另一台服务minion2上的对外IP。</p>
<p>在minion2上执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># ovs-vsctl add-port obr0 gre0 -- set Interface gre0 type=gre options:remote_ip=172.29.88.207
</span></span></code></pre></td></tr></table>
</div>
</div><p>至此，minion1和minion2之间的隧道已经建立。然后我们在minion1和minion2上创建Linux网桥kbr0替代Docker默认的docker0（我们假设minion1和minion2都已安装Docker），设置minion1的kbr0的地址为172.17.1.1/24， minion2的kbr0的地址为172.17.2.1/24，并添加obr0为kbr0的接口，以下命令在minion1和minion2上执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># brctl addbr kbr0              //创建linux bridge代替docker0
</span></span><span class="line"><span class="cl"># brctl addif kbr0 obr0         //添加obr0为kbr0的接口
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># ip link set dev docker0 down  //设置docker0为down状态
</span></span><span class="line"><span class="cl"># ip link del dev docker0       //删除docker0，可选
</span></span></code></pre></td></tr></table>
</div>
</div><p>查看这些接口的状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># service openvswitch-switch status
</span></span><span class="line"><span class="cl"># ovs-vsctl show
</span></span><span class="line"><span class="cl">9d248403-943c-41c0-b2d0-3f9b130cdd3f
</span></span><span class="line"><span class="cl">    Bridge &#34;obr0&#34;
</span></span><span class="line"><span class="cl">        Port &#34;gre0&#34;
</span></span><span class="line"><span class="cl">            Interface &#34;gre0&#34;
</span></span><span class="line"><span class="cl">                type: gre
</span></span><span class="line"><span class="cl">                options: {remote_ip=&#34;172.29.88.207&#34;}
</span></span><span class="line"><span class="cl">        Port &#34;obr0&#34;
</span></span><span class="line"><span class="cl">            Interface &#34;obr0&#34;
</span></span><span class="line"><span class="cl">                type: internal
</span></span><span class="line"><span class="cl">    ovs_version: &#34;2.0.2&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># brctl show
</span></span><span class="line"><span class="cl">bridge name	bridge id		STP enabled	interfaces
</span></span><span class="line"><span class="cl">docker0		8000.56847afe9799	no		
</span></span><span class="line"><span class="cl">kbr0		8000.620ff7ee9c49	no		obr0
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了使新建的kbr0在每次系统重启后任然有效，我们在minion1的<code>/etc/network/interfaces</code>文件中追加内容如下：（在CentOS上会有些不一样）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># vi /etc/network/interfaces
</span></span><span class="line"><span class="cl">auto kbr0
</span></span><span class="line"><span class="cl">iface kbr0 inet static
</span></span><span class="line"><span class="cl">        address 172.17.1.1
</span></span><span class="line"><span class="cl">        netmask 255.255.255.0
</span></span><span class="line"><span class="cl">        gateway 172.17.1.0
</span></span><span class="line"><span class="cl">        dns-nameservers 172.31.1.1
</span></span></code></pre></td></tr></table>
</div>
</div><p>同样在minion2上追加类似内容，只需修改address为172.17.2.1和gateway为172.17.2.0即可，然后执行<code>ip link set dev kbr0 up</code>，你能在minion1和minion2上发现kbr0都设置了相应的IP地址。为了验证我们创建的隧道是否能通信，我们在minion1和minion2上相互ping对方kbr0的IP地址，从下面的结果发现是不通的，经查找这是因为在minion1和minion2上缺少访问172.17.1.1和172.17.2.1的路由，因此我们需要添加路由保证彼此之间能通信：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">minion1上执行:
</span></span><span class="line"><span class="cl"># ip route add 172.17.2.0/24 via 172.29.88.208 dev eth0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">minion2上执行:
</span></span><span class="line"><span class="cl"># ip route add 172.17.1.0/24 via 172.29.88.207 dev eth0
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在可以ping通对方的虚拟网络了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ ping 172.17.2.1
</span></span><span class="line"><span class="cl">PING 172.17.2.1 (172.17.2.1) 56(84) bytes of data.
</span></span><span class="line"><span class="cl">64 bytes from 172.17.2.1: icmp_seq=1 ttl=64 time=0.334 ms
</span></span><span class="line"><span class="cl">64 bytes from 172.17.2.1: icmp_seq=2 ttl=64 time=0.253 ms
</span></span><span class="line"><span class="cl">^C
</span></span><span class="line"><span class="cl">--- 172.17.2.1 ping statistics ---
</span></span><span class="line"><span class="cl">2 packets transmitted, 2 received, 0% packet loss, time 999ms
</span></span><span class="line"><span class="cl">rtt min/avg/max/mdev = 0.253/0.293/0.334/0.043 ms
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面安装 Kubernetes APIServer 及kubelet、proxy等服务。</p>
<h1 id="3-安装kubernetes-apiserver">3. 安装Kubernetes APIServer<a hidden class="anchor" aria-hidden="true" href="#3-安装kubernetes-apiserver">#</a></h1>
<h2 id="31-下载安装kubernetes各组件">3.1 下载安装kubernetes各组件<a hidden class="anchor" aria-hidden="true" href="#31-下载安装kubernetes各组件">#</a></h2>
<p>可以自己从源码编译kubernetes（需要安装golang环境），也可以从<a href="https://github.com/GoogleCloudPlatform/kubernetes/releases">GitHub Kubernetes repo release page.</a>选择编译好的二进制版本（v0.7.2）下载，为了方便后面启动或关闭kubernetes组件，我们同时下载二进制包和源码包：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="c1"># cd /usr/local/src</span>
</span></span><span class="line"><span class="cl"><span class="c1"># wget https://github.com/coreos/etcd/releases/download/v2.0.0-rc.1/etcd-v2.0.0-rc.1-linux-amd64.tar.gz</span>
</span></span><span class="line"><span class="cl"><span class="c1"># wget https://github.com/GoogleCloudPlatform/kubernetes/releases/download/v0.7.2/kubernetes.tar.gz</span>
</span></span><span class="line"><span class="cl"><span class="c1"># wget https://github.com/GoogleCloudPlatform/kubernetes/archive/v0.7.2.zip</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后解压下载的kubernetes和etcd包，并在kubernetes(minion1)、minion2上创建目录<code>/opt/bin</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># mkdir /opt/bin        //这一步APIserver和所有minions上都要创建
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">解压kubernetes
</span></span><span class="line"><span class="cl">src# tar xf kubernetes.tar.gz
</span></span><span class="line"><span class="cl"># ll 
</span></span><span class="line"><span class="cl">drwxr-xr-x  3  501 staff     4096 Dec 19 02:32 etcd-v2.0.0-rc.1-linux-amd64/
</span></span><span class="line"><span class="cl">-rw-r--r--  1 root root   6223584 Jan  6 14:39 etcd-v2.0.0-rc.1-linux-amd64.tar.gz
</span></span><span class="line"><span class="cl">drwxr-xr-x  7 root root      4096 Nov 20 06:35 kubernetes/
</span></span><span class="line"><span class="cl">-rw-r--r--  1 root root  82300483 Jan  6 14:37 kubernetes.tar.gz
</span></span><span class="line"><span class="cl">-rw-r--r--  1 root root  9170754 Jan  9 14:47 v0.7.2.zip
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># cd kubernetes/server
</span></span><span class="line"><span class="cl"># tar xf kubernetes-server-linux-amd64.tar.gz
</span></span><span class="line"><span class="cl"># cd kubernetes/server/bin/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">APIserver本身需要的是kube-apiserver kube-scheduler kube-controller-manager kubecfg四个
</span></span><span class="line"><span class="cl"># cp -a kube* /opt/bin/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">把proxy和kubelet复制到其他minions，确保这些文件都是可执行的
</span></span><span class="line"><span class="cl"># scp kube-proxy kubelet root@172.29.88.207:/opt/bin
</span></span><span class="line"><span class="cl"># scp kube-proxy kubelet root@172.29.88.208:/opt/bin
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>/opt/bin</code>并没有加入系统<code>PATH</code>，所以<code>kube-apiserver -version</code>是看不到结果，但在后面配置的服务中会自动加入（<code>PATH=$PATH:/opt/bin</code>）。</p>
<h2 id="32-解压安装etcd">3.2 解压安装etcd<a hidden class="anchor" aria-hidden="true" href="#32-解压安装etcd">#</a></h2>
<p><code>etcd</code>在这里的作用是服务发现存储仓库，通俗的来讲就是记录kubernetes启动了多少pods、services、replicationController以及它们的信息等，详细介绍见<a href="http//">这里</a>。此外版本2.0与v0.4.6在启动参数上的写法有一定差别。</p>
<pre><code># tar xf etcd-v2.0.0-rc.1-linux-amd64.tar.gz &amp;&amp; cd etcd-v2.0.0-rc.1-linux-amd64/
# cp -a etcd etcdctl /opt/bin
</code></pre>
<h2 id="33-配置kube-apiserver等为upstart脚本启动">3.3 配置kube-apiserver等为upstart脚本启动<a hidden class="anchor" aria-hidden="true" href="#33-配置kube-apiserver等为upstart脚本启动">#</a></h2>
<p>这一步主要是为了管理kube-apiserver等进程的方便，避免每次都手动启动各服务、添加冗长的启动参数选项，而且在不同的系统平台下kubernetes已经提供了相应的工具。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">解压kubernetes*源码包*
</span></span><span class="line"><span class="cl">src# unzip xf v0.7.2.zip &amp;&amp; cd kubernetes-0.7.2
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">这里比较奇怪的是最新release版本源码的cluster目录下是有ubuntu子目录的，但latest之前的下载后没有ubuntu目录
</span></span><span class="line"><span class="cl"># cd cluster/ubuntu
</span></span><span class="line"><span class="cl"># ll
</span></span><span class="line"><span class="cl">.. 2 root root 4096 Jan  8 17:39 default_scripts/   各组件默认启动参数
</span></span><span class="line"><span class="cl">.. 2 root root 4096 Jan  8 17:39 init_conf/         upstart启动方式
</span></span><span class="line"><span class="cl">.. 2 root root 4096 Jan  8 17:39 initd_scripts/     service启动方式，与upstart选其一
</span></span><span class="line"><span class="cl">.. 1 root root 1213 Jan  8 08:53 util.sh*     
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># ./util.sh
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>util.sh</code>脚本就是把当前目录下的service/upstart脚本、默认参数配置文件复制到<code>/etc</code>下，可以通过<code>service etcd start</code>的形式管理kubernetes。由于kubernetes更新速度极快，项目的文件和目录结构经常变化，请找准文件。接下来我们需要修改那些只适合本机使用的默认参数。（请注意备份先，因为后面能否正常跨机器管理docker与这些选项有关，特别是IP）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">etcd官方建议使用新的2379端口代替4001
</span></span><span class="line"><span class="cl"># vi /etc/default/etcd
</span></span><span class="line"><span class="cl">ETCD_OPTS=&#34;-listen-client-urls=http://0.0.0.0:4001&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># vi /etc/default/kube-apiserver
</span></span><span class="line"><span class="cl">KUBE_APISERVER_OPTS=&#34;--address=0.0.0.0 \
</span></span><span class="line"><span class="cl">--port=8080 \
</span></span><span class="line"><span class="cl">--etcd_servers=http://127.0.0.1:4001 \
</span></span><span class="line"><span class="cl">--logtostderr=true \
</span></span><span class="line"><span class="cl">--portal_net=11.1.1.0/24&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># vi /etc/default/kube-scheduler
</span></span><span class="line"><span class="cl">KUBE_SCHEDULER_OPTS=&#34;--logtostderr=true \
</span></span><span class="line"><span class="cl">--master=127.0.0.1:8080&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># vi /etc/default/kube-controller-manager
</span></span><span class="line"><span class="cl">KUBE_CONTROLLER_MANAGER_OPTS=&#34;--master=127.0.0.1:8080 \
</span></span><span class="line"><span class="cl">--machines=172.29.88.207,172.29.88.208 \
</span></span><span class="line"><span class="cl">--logtostderr=true&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">* 复制kubelet、kube-proxy等到minion1：
</span></span><span class="line"><span class="cl"># scp /etc/default/{kubelet,kube-proxy} 172.29.88.207:/etc/default/
</span></span><span class="line"><span class="cl"># scp /etc/init.d/{kubelet,kube-proxy} 172.29.88.207:/etc/init.d/
</span></span><span class="line"><span class="cl"># scp /etc/init/{kubelet.conf,kube-proxy.conf} 172.29.88.207:/etc/init/
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">* 在minion1端进行
</span></span><span class="line"><span class="cl"># vi /etc/default/kubelet
</span></span><span class="line"><span class="cl">KUBELET_OPTS=&#34;--address=172.29.88.207 \
</span></span><span class="line"><span class="cl">--port=10250 \
</span></span><span class="line"><span class="cl">--hostname_override=172.29.88.207 \
</span></span><span class="line"><span class="cl">--etcd_servers=http://172.29.88.206:4001 \
</span></span><span class="line"><span class="cl">--logtostderr=true&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># vi /etc/default/kube-proxy
</span></span><span class="line"><span class="cl">KUBE_PROXY_OPTS=&#34;--etcd_servers=http://172.29.88.207:4001 \
</span></span><span class="line"><span class="cl">--logtostderr=true&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">(对minion2重复上面 * 两个步骤，把上面.207改成.208)
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的各配置文件就是对应命令的选项，具体含义使用<code>-h</code>。这里只简单说明：</p>
<ol>
<li><code>etcd</code>服务APIserver和minions都要访问，也就是其他组件的<code>--etcd_servers</code>值（带http前缀）</li>
<li><code>kube-apiserver</code>监听在8080端口，也就是其他组件的<code>--master</code>值；<code>--portal_net</code>地址段不能与docker的桥接网卡kbr0重复，指定docker容器的IP段</li>
<li><code>etcd</code>、<code>kube-apiserver</code>、<code>kube-scheduler</code>、<code>kube-controller-manager</code>运行在apiserver（服务）端，<code>kubelet</code>、<code>kube-proxy</code>运行在minion（客户端）</li>
<li><code>kube-controller-manager</code>使用预先定义pod模板创建pods，保证指定数量的replicas在运行，默认监听在master的127.0.0.1:10252</li>
<li><code>kubelet</code>默认监听端口10250，也正是apiserver的<code>--kubelet_port</code>的值</li>
</ol>
<h2 id="34-启动">3.4 启动<a hidden class="anchor" aria-hidden="true" href="#34-启动">#</a></h2>
<p><strong>重启docker</strong>
接下来重启minion1、minion2上的Docker daemon（注意使用的网桥）：</p>
<pre><code># docker -d -b kbr0
</code></pre>
<p>由于后面的测试可能需要在线下载images，所以如果你的服务器无法访问docker hub，上面启动时记得设置<code>HTTP_PROXY</code>代理。</p>
<p><strong>启动apiserver</strong></p>
<pre><code># service etcd start
# service kube-apiserver start
</code></pre>
<p><code>kube-apiserver</code>启动后会自动运行<code>kube-scheduler</code>、<code>kube-controller-manager</code>，但修改配置后依然可以单独重启各个服务如<code>service kube-contoller-manager restart</code>。这些服务的日志可以从<code>/var/log/upstart/kube*</code>找到。</p>
<p><strong>在minion1、minion2上启动kubelet、kube-proxy</strong>：</p>
<pre><code># service kubelet start
# service kube-proxy start
</code></pre>
<h1 id="4-使用kubecfg部署测试应用">4. 使用kubecfg部署测试应用<a hidden class="anchor" aria-hidden="true" href="#4-使用kubecfg部署测试应用">#</a></h1>
<p>为了方便，我们使用Kubernetes提供的例子<a href="https://github.com/GoogleCloudPlatform/kubernetes/tree/master/examples/guestbook">Guestbook</a>（下载的源码example目录下可以找到）来演示Kubernetes管理跨机器运行的容器，下面我们根据Guestbook的步骤创建容器及服务。在下面的过程中如果是第一次操作，可能会有一定的等待时间，状态处于pending，这是因为第一次下载images需要一段时间。</p>
<h2 id="41-创建redis-master-pod和redis-master服务">4.1 创建redis-master Pod和redis-master服务<a hidden class="anchor" aria-hidden="true" href="#41-创建redis-master-pod和redis-master服务">#</a></h2>
<p>配置管理操作都在apiserver上执行，并且都是基于实现编写好的json格式。涉及到下载docker镜像的部分，如果没有外网，可能需要修改image的值或使用自己搭建的docker-registry：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># cd kubernetes-0.7.2/examples/guestbook/
</span></span><span class="line"><span class="cl"># cat redis-master.json
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  &#34;id&#34;: &#34;redis-master&#34;,
</span></span><span class="line"><span class="cl">  &#34;kind&#34;: &#34;Pod&#34;,
</span></span><span class="line"><span class="cl">  &#34;apiVersion&#34;: &#34;v1beta1&#34;,
</span></span><span class="line"><span class="cl">  &#34;desiredState&#34;: {
</span></span><span class="line"><span class="cl">    &#34;manifest&#34;: {
</span></span><span class="line"><span class="cl">      &#34;version&#34;: &#34;v1beta1&#34;,
</span></span><span class="line"><span class="cl">      &#34;id&#34;: &#34;redis-master&#34;,
</span></span><span class="line"><span class="cl">      &#34;containers&#34;: [{
</span></span><span class="line"><span class="cl">        &#34;name&#34;: &#34;master&#34;,
</span></span><span class="line"><span class="cl">        &#34;image&#34;: &#34;dockerfile/redis&#34;,
</span></span><span class="line"><span class="cl">        &#34;cpu&#34;: 100,
</span></span><span class="line"><span class="cl">        &#34;ports&#34;: [{
</span></span><span class="line"><span class="cl">          &#34;containerPort&#34;: 6379,
</span></span><span class="line"><span class="cl">          &#34;hostPort&#34;: 6379
</span></span><span class="line"><span class="cl">        }]
</span></span><span class="line"><span class="cl">      }]
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  },
</span></span><span class="line"><span class="cl">  &#34;labels&#34;: {
</span></span><span class="line"><span class="cl">    &#34;name&#34;: &#34;redis-master&#34;
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># kubecfg -h http://172.29.88.206:8080 -c redis-master.json create pods
</span></span><span class="line"><span class="cl"># kubecfg -h http://172.29.88.206:8080 -c redis-master-service.json create services
</span></span></code></pre></td></tr></table>
</div>
</div><p>完成上面的操作后，我们可以看到如下redis-master Pod被调度到172.29.88.207：
（下面直接list实际上是省略了<code>-h http://127.0.0.1:8080</code>）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># kubecfg list pods
</span></span><span class="line"><span class="cl">Name             Image(s)            Host               Labels              Status
</span></span><span class="line"><span class="cl">----------       ----------          ----------         ----------          ----------
</span></span><span class="line"><span class="cl">redis-master     dockerfile/redis    172.29.88.207/     name=redis-master   Running
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">查看services：
</span></span><span class="line"><span class="cl"># kubecfg list services
</span></span><span class="line"><span class="cl">Name            Labels                                    Selector            IP            Port
</span></span><span class="line"><span class="cl">----------      ----------                                ----------          ----------    ------
</span></span><span class="line"><span class="cl">kubernetes      component=apiserver,provider=kubernetes                       11.1.1.233    443
</span></span><span class="line"><span class="cl">kubernetes-ro   component=apiserver,provider=kubernetes                       11.1.1.204    80
</span></span><span class="line"><span class="cl">redis-master    name=redis-master                         name=redis-master   11.1.1.175    6379
</span></span></code></pre></td></tr></table>
</div>
</div><p>发现除了redis-master的服务之外，还有两个Kubernetes系统默认的服务kubernetes-ro和kubernetes。而且我们可以看到每个服务都有一个服务IP及相应的端口，对于服务IP，是一个虚拟地址，根据apiserver的<code>portal_net</code>选项设置的<code>CIDR</code>表示的IP地址段来选取，在我们的集群中设置为11.1.1.0/24。为此每新创建一个服务，apiserver都会在这个地址段中随机选择一个IP作为该服务的IP地址，而端口是事先确定的。对redis-master服务，其服务地址为11.1.1.175，端口为6379，与minion主机映射的端口也是6379。</p>
<h2 id="42-创建redis-slave-pod和redis-slave服务">4.2 创建redis-slave Pod和redis-slave服务<a hidden class="anchor" aria-hidden="true" href="#42-创建redis-slave-pod和redis-slave服务">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># kubecfg -h http://172.29.88.206:8080 -c redis-slave-controller.json create replicationControllers
</span></span><span class="line"><span class="cl"># kubecfg -h http://172.29.88.206:8080 -c redis-slave-service.json create services
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意上面的<code>redis-slave-controller.json</code>有个<code>&quot;replicas&quot;: 2</code>、<code>&quot;hostPort&quot;: 6380</code>，因为我们的集群中只有2个minions，如果为3的话，就会导致有2个Pod会调度到同一台minion上，产生端口冲突，有一个Pod会一直处于pending状态，不能被调度（可以通过日志看到原因）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># kubecfg list pods
</span></span><span class="line"><span class="cl">Name                 Image(s)                     Host             Labels                                       Status
</span></span><span class="line"><span class="cl">----------           ----------                   ----------       ----------                                   --------
</span></span><span class="line"><span class="cl">2c2a06...c2971614d   brendanburns/redis-slave     172.29.88.208/   name=redisslave,uses=redis-master            Running
</span></span><span class="line"><span class="cl">2c2ad5...c2971614d   brendanburns/redis-slave     172.29.88.207/   name=redisslave,uses=redis-master            Running
</span></span><span class="line"><span class="cl">redis-master         dockerfile/redis             172.29.88.207/   name=redis-master                            Running
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># kubecfg list services
</span></span><span class="line"><span class="cl">Name              Labels                                    Selector            IP                  Port
</span></span><span class="line"><span class="cl">----------        ----------                                ----------          ----------          --------
</span></span><span class="line"><span class="cl">kubernetes        component=apiserver,provider=kubernetes                       11.1.1.233          443
</span></span><span class="line"><span class="cl">kubernetes-ro     component=apiserver,provider=kubernetes                       11.1.1.204          80
</span></span><span class="line"><span class="cl">redis-master      name=redis-master                         name=redis-master   11.1.1.175          6379
</span></span><span class="line"><span class="cl">redisslave        name=redisslave                           name=redisslave     11.1.1.131          6379
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="43-创建frontend-pod和frontend服务">4.3 创建Frontend Pod和Frontend服务<a hidden class="anchor" aria-hidden="true" href="#43-创建frontend-pod和frontend服务">#</a></h2>
<p>前面2步都是guestbook的redis数据存储，现在部署应用：(修改<code>frontend-controller.json</code>的<code>replicas</code>为2)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># kubecfg -h http://172.29.88.206:8080 -c frontend-controller.json create replicationControllers
</span></span><span class="line"><span class="cl"># kubecfg -h http://172.29.88.206:8080 -c frontend-service.json create services
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># kubecfg -h http://172.29.88.206:8080 list pods
</span></span><span class="line"><span class="cl">Name                 Image(s)                                 Host              Labels                                       Status
</span></span><span class="line"><span class="cl">----------           ----------                               ----------        ----------                                   ----------
</span></span><span class="line"><span class="cl">2c2a06...c2971614d   brendanburns/redis-slave                 172.29.88.208/    name=redisslave,uses=redis-master            Running
</span></span><span class="line"><span class="cl">2c2ad5...c2971614d   brendanburns/redis-slave                 172.29.88.207/    name=redisslave,uses=redis-master            Running
</span></span><span class="line"><span class="cl">d87744...c2971614d   kubernetes/example-guestbook-php-redis   172.29.88.207/    name=frontend,uses=redisslave,redis-master   Running
</span></span><span class="line"><span class="cl">redis-master         dockerfile/redis                         172.29.88.207/    name=redis-master                            Running
</span></span><span class="line"><span class="cl">1370b9...c2971614d   kubernetes/example-guestbook-php-redis   172.29.88.208/    name=frontend,uses=redisslave,redis-master   Running
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># kubecfg -h http://172.29.88.206:8080 list services
</span></span><span class="line"><span class="cl">Name             Labels                                    Selector            IP            Port
</span></span><span class="line"><span class="cl">----------       ----------                                ----------          ----------    ------
</span></span><span class="line"><span class="cl">redis-master     name=redis-master                         name=redis-master   11.1.1.175    6379
</span></span><span class="line"><span class="cl">redisslave       name=redisslave                           name=redisslave     11.1.1.131    6379
</span></span><span class="line"><span class="cl">frontend         name=frontend                             name=frontend       11.1.1.124    80
</span></span><span class="line"><span class="cl">kubernetes       component=apiserver,provider=kubernetes                       11.1.1.233    443
</span></span><span class="line"><span class="cl">kubernetes-ro    component=apiserver,provider=kubernetes                       11.1.1.204    80
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过查看可知 Frontend Pod 也被调度到两台minion，服务IP为11.1.1.124，端口是80，映射到外面minions的端口为8000（可以通过<code>ps -ef|grep docker-proxy</code>发现）。</p>
<h2 id="44-其他操作更新删除查看">4.4 其他操作（更新、删除、查看）<a hidden class="anchor" aria-hidden="true" href="#44-其他操作更新删除查看">#</a></h2>
<p><strong>删除</strong>
除此之外，你可以删除Pod、Service，如删除minion1上的redis-slave Pod：</p>
<pre><code>kubecfg -h http://172.29.88.206:8080 delete pods/2c2ad505-96fd-11e4-9c0b-000c2971614d
Status
----------
Success
</code></pre>
<p>格式为<code>services/服务Name</code>、<code>pods/pods名字</code>，不必关心从哪个minion上删除了。需要提醒的是，这里pods的replcas为2，所以即使删除了这个pods，kubernetes为自动为你重新启动一个。</p>
<p><strong>更新</strong>
更新ReplicationController的Replicas数量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># kubecfg list replicationControllers
</span></span><span class="line"><span class="cl">Name                   Image(s)                                 Selector            Replicas
</span></span><span class="line"><span class="cl">----------             ----------                               ----------          ----------
</span></span><span class="line"><span class="cl">frontendController     kubernetes/example-guestbook-php-redis   name=frontend       2
</span></span><span class="line"><span class="cl">redisSlaveController   brendanburns/redis-slave                 name=redisslave     2
</span></span></code></pre></td></tr></table>
</div>
</div><p>把frontendController的Replicas更新为1，则这行如下命令，然后再通过上面的命令查看frontendController信息，发现Replicas已变为1：</p>
<pre><code>kubecfg -h http://172.29.88.206:8080 resize frontendController 1
</code></pre>
<p><strong>查看</strong>
Kubernetes内置提供了一个简单的UI来查看pods、services、replicationControllers，但极其简陋，暂时可以忽略，访问<code>http://172.29.88.206:8080/static/#/groups//selector/</code>：
<img alt="kubernetes-simpleui" loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/kubernetes-simpleui.png"></p>
<p>在浏览器访问api：<code>http://172.29.88.206:8080/api/v1beta1/replicationControllers</code> 。
<img alt="kubernetes-api" loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/kubernetes-api.png"></p>
<p>etcd做服务发现，可以通过api访问其内容，访问<code>http://172.29.88.206:4001/v2/keys/registry/services/endpoints/default</code> ，得到json格式数据。</p>
<h2 id="45-演示guestbook">4.5 演示guestbook<a hidden class="anchor" aria-hidden="true" href="#45-演示guestbook">#</a></h2>
<p>通过上面的结果可知当前提供前端服务的PHP和提供数据存储的后端服务Redis master的Pod分别运行在172.29.88.208和172.29.88.207上，即容器运行在不同主机上，还有Redis slave也运行在两台不同的主机上，它会从Redis master同步前端写入Redis master的数据。下面我们从两方面验证Kubernetes能提供跨机器间容器的通信：</p>
<p><strong>浏览器访问留言簿</strong>
在浏览器打开<code>http://${IPAddress}:8000</code>，IPAddress为PHP容器运行的minion的IP地址，其暴漏的端口为8000，这里IP_Address为172.29.88.208。打开浏览器会显示如下信息：
<img alt="kubernetes-guestbook1" loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/kubernetes-guestbook1.png"></p>
<p>你可以输入信息并提交，然后Submit按钮下方会显示你输入的信息：
<img alt="kubernetes-guestbook2" loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/kubernetes-guestbook2.png">
由于前端PHP容器和后端Redis master容器分别在两台minion上，因此PHP在访问Redis master服务时一定得跨机器通信，可见Kubernetes的实现方式避免了用link只能在同一主机上实现容器间通信的缺陷。</p>
<p><strong>从redis后端验证</strong>
我们从后端数据层验证不同机器容器间的通信。根据上面的输出结果发现Redis slave和Redis master分别调度到两台不同的minion上，在172.29.88.207主机上执行<code>docker exec -ti e5941db7e424 /bin/sh</code>，e5941db7e424 master的容器ID（<code>docker ps</code>），进入容器后通过redis-cli命令查看从浏览器输入的信息如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># docker exec -ti e5941db7e424 /bin/sh
</span></span><span class="line"><span class="cl"># redis-cli
</span></span><span class="line"><span class="cl">127.0.0.1:6379&gt; keys *
</span></span><span class="line"><span class="cl">1) &#34;messages&#34;
</span></span><span class="line"><span class="cl">127.0.0.1:6379&gt; get messages
</span></span><span class="line"><span class="cl">&#34;,Hi, Sean,Kubernetes,,llll,abc,\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xd4\xb0\xef\xbf\xbd,sync info,&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>类似可以在172.29.88.208的redis-slave上看到同样的内容。由此可见Redis master和Redis slave之间数据同步正常，OVS GRE隧道技术使得跨机器间容器正常通信。</p>
<h2 id="46-排错提示">4.6 排错提示<a hidden class="anchor" aria-hidden="true" href="#46-排错提示">#</a></h2>
<ol>
<li>所有的kubelet必须起来，否则报错<code>F0319 16:56:08.058335    9960 kubecfg.go:438] Got request error: The requested resource does not exist.</code></li>
<li>必须使用-b启动docker，否则无法访问8000端口，redis-slave也没同步</li>
<li>注意pods一直处于Pending或Failed状态时去apiserver或其他组件日志里查看错误，是否是由于端口绑定冲突导致。</li>
</ol>
<p><strong>参考</strong></p>
<ul>
<li>
<p><a href="http://www.infoq.com/cn/articles/centos7-practical-kubernetes-deployment">CentOS 7实战Kubernetes部署</a></p>
</li>
<li>
<p><a href="https://github.com/GoogleCloudPlatform/kubernetes/tree/master/examples/guestbook">kubernetes-examples-guestbook</a></p>
</li>
<li>
<p><a href="https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/getting-started-guides/ubuntu_single_node.md">getting_started_guides-ubuntu_single_node</a></p>
</li>
<li>
<p><a href="http://blog.liuts.com/category/42/1/1/">基于kubernetes构建Docker集群管理详解</a></p>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/docker/">Docker</a></li>
      <li><a href="http://localhost:1313/tags/linux/">Linux</a></li>
      <li><a href="http://localhost:1313/tags/kubernetes/">Kubernetes</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/2015/02/baidu-complain/">
    <span class="title">« Prev</span>
    <br>
    <span>我为何厌恶百度的产品</span>
  </a>
  <a class="next" href="http://localhost:1313/2015/02/docker-kubernetes-arch-introduction/">
    <span class="title">Next »</span>
    <br>
    <span>开源容器集群管理系统Kubernetes架构及组件介绍</span>
  </a>
</nav>

  </footer><script src="https://utteranc.es/client.js"
        repo="seanlook/sean-notes-comment"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Sean&#39;s Note</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
