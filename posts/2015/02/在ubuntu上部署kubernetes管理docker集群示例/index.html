<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>在ubuntu上部署Kubernetes管理docker集群示例 | Sean Note</title>
<meta name="keywords" content="docker, linux, kubernetes">
<meta name="description" content="本文通过实际操作来演示Kubernetes的使用，因为环境有限，集群部署在本地3个ubuntu上，主要包括如下内容：
部署环境介绍，以及Kubernetes集群逻辑架构 安装部署Open vSwitch跨机器容器通信工具 安装部署Etcd和Kubernetes的各大组件 演示Kubernetes管理容器和服务 关于 Kubernetes 系统架构及组件介绍见这里。
1. 部署环境及架构 vSphere: 5.1 操作系统: ubuntu 14.04 x86_64 Open vSwith版本: 2.0.2 Kubernetes: v0.7.2 Etcd版本: 2.0.0-rc.1 Docker版本: 1.4.1 服务器信息： Role Hostname IP Address APIServer kubernetes 172.29.88.206 Minion minion1 172.29.88.207 Minion minion2 172.29.88.208 在详细介绍部署Kubernetes集群前，先给大家展示下集群的逻辑架构。从下图可知，整个系统分为两部分，第一部分是Kubernetes APIServer，是整个系统的核心，承担集群中所有容器的管理工作；第二部分是minion，运行Container Daemon，是所有容器栖息之地，同时在minion上运行Open vSwitch程序，通过GRE Tunnel负责minions之间Pod的网络通信工作。 2. 安装Open vSwitch及配置GRE 为了解决跨minion之间Pod的通信问题，我们在每个minion上安装Open vSwtich，并使用GRE或者VxLAN使得跨机器之间P11od能相互通信，本文使用GRE，而VxLAN通常用在需要隔离的大规模网络中。对于Open vSwitch的介绍请参考另一篇文章Open vSwitch。
sudo apt-get install openvswitch-switch bridge-utils 安装完Open vSwitch和桥接工具后，接下来便建立minion0和minion1之间的隧道。首先在minion1和minion2上分别建立OVS Bridge：
# ovs-vsctl add-br obr0 接下来建立gre，并将新建的gre0添加到obr0，在minion1上执行如下命令：
# ovs-vsctl add-port obr0 gre0 -- set Interface gre0 type=gre options:remote_ip=172.">
<meta name="author" content="admin">
<link rel="canonical" href="http://xgknight.com/posts/2015/02/%E5%9C%A8ubuntu%E4%B8%8A%E9%83%A8%E7%BD%B2kubernetes%E7%AE%A1%E7%90%86docker%E9%9B%86%E7%BE%A4%E7%A4%BA%E4%BE%8B/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css" integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://xgknight.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://xgknight.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://xgknight.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://xgknight.com/apple-touch-icon.png">
<link rel="mask-icon" href="http://xgknight.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="在ubuntu上部署Kubernetes管理docker集群示例" />
<meta property="og:description" content="本文通过实际操作来演示Kubernetes的使用，因为环境有限，集群部署在本地3个ubuntu上，主要包括如下内容：
部署环境介绍，以及Kubernetes集群逻辑架构 安装部署Open vSwitch跨机器容器通信工具 安装部署Etcd和Kubernetes的各大组件 演示Kubernetes管理容器和服务 关于 Kubernetes 系统架构及组件介绍见这里。
1. 部署环境及架构 vSphere: 5.1 操作系统: ubuntu 14.04 x86_64 Open vSwith版本: 2.0.2 Kubernetes: v0.7.2 Etcd版本: 2.0.0-rc.1 Docker版本: 1.4.1 服务器信息： Role Hostname IP Address APIServer kubernetes 172.29.88.206 Minion minion1 172.29.88.207 Minion minion2 172.29.88.208 在详细介绍部署Kubernetes集群前，先给大家展示下集群的逻辑架构。从下图可知，整个系统分为两部分，第一部分是Kubernetes APIServer，是整个系统的核心，承担集群中所有容器的管理工作；第二部分是minion，运行Container Daemon，是所有容器栖息之地，同时在minion上运行Open vSwitch程序，通过GRE Tunnel负责minions之间Pod的网络通信工作。 2. 安装Open vSwitch及配置GRE 为了解决跨minion之间Pod的通信问题，我们在每个minion上安装Open vSwtich，并使用GRE或者VxLAN使得跨机器之间P11od能相互通信，本文使用GRE，而VxLAN通常用在需要隔离的大规模网络中。对于Open vSwitch的介绍请参考另一篇文章Open vSwitch。
sudo apt-get install openvswitch-switch bridge-utils 安装完Open vSwitch和桥接工具后，接下来便建立minion0和minion1之间的隧道。首先在minion1和minion2上分别建立OVS Bridge：
# ovs-vsctl add-br obr0 接下来建立gre，并将新建的gre0添加到obr0，在minion1上执行如下命令：
# ovs-vsctl add-port obr0 gre0 -- set Interface gre0 type=gre options:remote_ip=172." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://xgknight.com/posts/2015/02/%E5%9C%A8ubuntu%E4%B8%8A%E9%83%A8%E7%BD%B2kubernetes%E7%AE%A1%E7%90%86docker%E9%9B%86%E7%BE%A4%E7%A4%BA%E4%BE%8B/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-02-07T13:21:25+00:00" />
<meta property="article:modified_time" content="2015-02-07T13:21:25+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="在ubuntu上部署Kubernetes管理docker集群示例"/>
<meta name="twitter:description" content="本文通过实际操作来演示Kubernetes的使用，因为环境有限，集群部署在本地3个ubuntu上，主要包括如下内容：
部署环境介绍，以及Kubernetes集群逻辑架构 安装部署Open vSwitch跨机器容器通信工具 安装部署Etcd和Kubernetes的各大组件 演示Kubernetes管理容器和服务 关于 Kubernetes 系统架构及组件介绍见这里。
1. 部署环境及架构 vSphere: 5.1 操作系统: ubuntu 14.04 x86_64 Open vSwith版本: 2.0.2 Kubernetes: v0.7.2 Etcd版本: 2.0.0-rc.1 Docker版本: 1.4.1 服务器信息： Role Hostname IP Address APIServer kubernetes 172.29.88.206 Minion minion1 172.29.88.207 Minion minion2 172.29.88.208 在详细介绍部署Kubernetes集群前，先给大家展示下集群的逻辑架构。从下图可知，整个系统分为两部分，第一部分是Kubernetes APIServer，是整个系统的核心，承担集群中所有容器的管理工作；第二部分是minion，运行Container Daemon，是所有容器栖息之地，同时在minion上运行Open vSwitch程序，通过GRE Tunnel负责minions之间Pod的网络通信工作。 2. 安装Open vSwitch及配置GRE 为了解决跨minion之间Pod的通信问题，我们在每个minion上安装Open vSwtich，并使用GRE或者VxLAN使得跨机器之间P11od能相互通信，本文使用GRE，而VxLAN通常用在需要隔离的大规模网络中。对于Open vSwitch的介绍请参考另一篇文章Open vSwitch。
sudo apt-get install openvswitch-switch bridge-utils 安装完Open vSwitch和桥接工具后，接下来便建立minion0和minion1之间的隧道。首先在minion1和minion2上分别建立OVS Bridge：
# ovs-vsctl add-br obr0 接下来建立gre，并将新建的gre0添加到obr0，在minion1上执行如下命令：
# ovs-vsctl add-port obr0 gre0 -- set Interface gre0 type=gre options:remote_ip=172."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://xgknight.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "在ubuntu上部署Kubernetes管理docker集群示例",
      "item": "http://xgknight.com/posts/2015/02/%E5%9C%A8ubuntu%E4%B8%8A%E9%83%A8%E7%BD%B2kubernetes%E7%AE%A1%E7%90%86docker%E9%9B%86%E7%BE%A4%E7%A4%BA%E4%BE%8B/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "在ubuntu上部署Kubernetes管理docker集群示例",
  "name": "在ubuntu上部署Kubernetes管理docker集群示例",
  "description": "本文通过实际操作来演示Kubernetes的使用，因为环境有限，集群部署在本地3个ubuntu上，主要包括如下内容：\n部署环境介绍，以及Kubernetes集群逻辑架构 安装部署Open vSwitch跨机器容器通信工具 安装部署Etcd和Kubernetes的各大组件 演示Kubernetes管理容器和服务 关于 Kubernetes 系统架构及组件介绍见这里。\n1. 部署环境及架构 vSphere: 5.1 操作系统: ubuntu 14.04 x86_64 Open vSwith版本: 2.0.2 Kubernetes: v0.7.2 Etcd版本: 2.0.0-rc.1 Docker版本: 1.4.1 服务器信息： Role Hostname IP Address APIServer kubernetes 172.29.88.206 Minion minion1 172.29.88.207 Minion minion2 172.29.88.208 在详细介绍部署Kubernetes集群前，先给大家展示下集群的逻辑架构。从下图可知，整个系统分为两部分，第一部分是Kubernetes APIServer，是整个系统的核心，承担集群中所有容器的管理工作；第二部分是minion，运行Container Daemon，是所有容器栖息之地，同时在minion上运行Open vSwitch程序，通过GRE Tunnel负责minions之间Pod的网络通信工作。 2. 安装Open vSwitch及配置GRE 为了解决跨minion之间Pod的通信问题，我们在每个minion上安装Open vSwtich，并使用GRE或者VxLAN使得跨机器之间P11od能相互通信，本文使用GRE，而VxLAN通常用在需要隔离的大规模网络中。对于Open vSwitch的介绍请参考另一篇文章Open vSwitch。\nsudo apt-get install openvswitch-switch bridge-utils 安装完Open vSwitch和桥接工具后，接下来便建立minion0和minion1之间的隧道。首先在minion1和minion2上分别建立OVS Bridge：\n# ovs-vsctl add-br obr0 接下来建立gre，并将新建的gre0添加到obr0，在minion1上执行如下命令：\n# ovs-vsctl add-port obr0 gre0 -- set Interface gre0 type=gre options:remote_ip=172.",
  "keywords": [
    "docker", "linux", "kubernetes"
  ],
  "articleBody": "本文通过实际操作来演示Kubernetes的使用，因为环境有限，集群部署在本地3个ubuntu上，主要包括如下内容：\n部署环境介绍，以及Kubernetes集群逻辑架构 安装部署Open vSwitch跨机器容器通信工具 安装部署Etcd和Kubernetes的各大组件 演示Kubernetes管理容器和服务 关于 Kubernetes 系统架构及组件介绍见这里。\n1. 部署环境及架构 vSphere: 5.1 操作系统: ubuntu 14.04 x86_64 Open vSwith版本: 2.0.2 Kubernetes: v0.7.2 Etcd版本: 2.0.0-rc.1 Docker版本: 1.4.1 服务器信息： Role Hostname IP Address APIServer kubernetes 172.29.88.206 Minion minion1 172.29.88.207 Minion minion2 172.29.88.208 在详细介绍部署Kubernetes集群前，先给大家展示下集群的逻辑架构。从下图可知，整个系统分为两部分，第一部分是Kubernetes APIServer，是整个系统的核心，承担集群中所有容器的管理工作；第二部分是minion，运行Container Daemon，是所有容器栖息之地，同时在minion上运行Open vSwitch程序，通过GRE Tunnel负责minions之间Pod的网络通信工作。 2. 安装Open vSwitch及配置GRE 为了解决跨minion之间Pod的通信问题，我们在每个minion上安装Open vSwtich，并使用GRE或者VxLAN使得跨机器之间P11od能相互通信，本文使用GRE，而VxLAN通常用在需要隔离的大规模网络中。对于Open vSwitch的介绍请参考另一篇文章Open vSwitch。\nsudo apt-get install openvswitch-switch bridge-utils 安装完Open vSwitch和桥接工具后，接下来便建立minion0和minion1之间的隧道。首先在minion1和minion2上分别建立OVS Bridge：\n# ovs-vsctl add-br obr0 接下来建立gre，并将新建的gre0添加到obr0，在minion1上执行如下命令：\n# ovs-vsctl add-port obr0 gre0 -- set Interface gre0 type=gre options:remote_ip=172.29.88.208 上面的remoute_ip是另一台服务minion2上的对外IP。\n在minion2上执行：\n# ovs-vsctl add-port obr0 gre0 -- set Interface gre0 type=gre options:remote_ip=172.29.88.207 至此，minion1和minion2之间的隧道已经建立。然后我们在minion1和minion2上创建Linux网桥kbr0替代Docker默认的docker0（我们假设minion1和minion2都已安装Docker），设置minion1的kbr0的地址为172.17.1.1/24， minion2的kbr0的地址为172.17.2.1/24，并添加obr0为kbr0的接口，以下命令在minion1和minion2上执行：\n# brctl addbr kbr0 //创建linux bridge代替docker0 # brctl addif kbr0 obr0 //添加obr0为kbr0的接口 # ip link set dev docker0 down //设置docker0为down状态 # ip link del dev docker0 //删除docker0，可选 查看这些接口的状态：\n# service openvswitch-switch status # ovs-vsctl show 9d248403-943c-41c0-b2d0-3f9b130cdd3f Bridge \"obr0\" Port \"gre0\" Interface \"gre0\" type: gre options: {remote_ip=\"172.29.88.207\"} Port \"obr0\" Interface \"obr0\" type: internal ovs_version: \"2.0.2\" # brctl show bridge name\tbridge id\tSTP enabled\tinterfaces docker0\t8000.56847afe9799\tno\tkbr0\t8000.620ff7ee9c49\tno\tobr0 为了使新建的kbr0在每次系统重启后任然有效，我们在minion1的/etc/network/interfaces文件中追加内容如下：（在CentOS上会有些不一样）\n# vi /etc/network/interfaces auto kbr0 iface kbr0 inet static address 172.17.1.1 netmask 255.255.255.0 gateway 172.17.1.0 dns-nameservers 172.31.1.1 同样在minion2上追加类似内容，只需修改address为172.17.2.1和gateway为172.17.2.0即可，然后执行ip link set dev kbr0 up，你能在minion1和minion2上发现kbr0都设置了相应的IP地址。为了验证我们创建的隧道是否能通信，我们在minion1和minion2上相互ping对方kbr0的IP地址，从下面的结果发现是不通的，经查找这是因为在minion1和minion2上缺少访问172.17.1.1和172.17.2.1的路由，因此我们需要添加路由保证彼此之间能通信：\nminion1上执行: # ip route add 172.17.2.0/24 via 172.29.88.208 dev eth0 minion2上执行: # ip route add 172.17.1.0/24 via 172.29.88.207 dev eth0 现在可以ping通对方的虚拟网络了：\n$ ping 172.17.2.1 PING 172.17.2.1 (172.17.2.1) 56(84) bytes of data. 64 bytes from 172.17.2.1: icmp_seq=1 ttl=64 time=0.334 ms 64 bytes from 172.17.2.1: icmp_seq=2 ttl=64 time=0.253 ms ^C --- 172.17.2.1 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 999ms rtt min/avg/max/mdev = 0.253/0.293/0.334/0.043 ms 下面安装 Kubernetes APIServer 及kubelet、proxy等服务。\n3. 安装Kubernetes APIServer 3.1 下载安装kubernetes各组件 可以自己从源码编译kubernetes（需要安装golang环境），也可以从GitHub Kubernetes repo release page.选择编译好的二进制版本（v0.7.2）下载，为了方便后面启动或关闭kubernetes组件，我们同时下载二进制包和源码包：\n# cd /usr/local/src # wget https://github.com/coreos/etcd/releases/download/v2.0.0-rc.1/etcd-v2.0.0-rc.1-linux-amd64.tar.gz # wget https://github.com/GoogleCloudPlatform/kubernetes/releases/download/v0.7.2/kubernetes.tar.gz # wget https://github.com/GoogleCloudPlatform/kubernetes/archive/v0.7.2.zip 然后解压下载的kubernetes和etcd包，并在kubernetes(minion1)、minion2上创建目录/opt/bin\n# mkdir /opt/bin //这一步APIserver和所有minions上都要创建 解压kubernetes src# tar xf kubernetes.tar.gz # ll drwxr-xr-x 3 501 staff 4096 Dec 19 02:32 etcd-v2.0.0-rc.1-linux-amd64/ -rw-r--r-- 1 root root 6223584 Jan 6 14:39 etcd-v2.0.0-rc.1-linux-amd64.tar.gz drwxr-xr-x 7 root root 4096 Nov 20 06:35 kubernetes/ -rw-r--r-- 1 root root 82300483 Jan 6 14:37 kubernetes.tar.gz -rw-r--r-- 1 root root 9170754 Jan 9 14:47 v0.7.2.zip # cd kubernetes/server # tar xf kubernetes-server-linux-amd64.tar.gz # cd kubernetes/server/bin/ APIserver本身需要的是kube-apiserver kube-scheduler kube-controller-manager kubecfg四个 # cp -a kube* /opt/bin/ 把proxy和kubelet复制到其他minions，确保这些文件都是可执行的 # scp kube-proxy kubelet root@172.29.88.207:/opt/bin # scp kube-proxy kubelet root@172.29.88.208:/opt/bin /opt/bin并没有加入系统PATH，所以kube-apiserver -version是看不到结果，但在后面配置的服务中会自动加入（PATH=$PATH:/opt/bin）。\n3.2 解压安装etcd etcd在这里的作用是服务发现存储仓库，通俗的来讲就是记录kubernetes启动了多少pods、services、replicationController以及它们的信息等，详细介绍见这里。此外版本2.0与v0.4.6在启动参数上的写法有一定差别。\n# tar xf etcd-v2.0.0-rc.1-linux-amd64.tar.gz \u0026\u0026 cd etcd-v2.0.0-rc.1-linux-amd64/ # cp -a etcd etcdctl /opt/bin 3.3 配置kube-apiserver等为upstart脚本启动 这一步主要是为了管理kube-apiserver等进程的方便，避免每次都手动启动各服务、添加冗长的启动参数选项，而且在不同的系统平台下kubernetes已经提供了相应的工具。\n解压kubernetes*源码包* src# unzip xf v0.7.2.zip \u0026\u0026 cd kubernetes-0.7.2 这里比较奇怪的是最新release版本源码的cluster目录下是有ubuntu子目录的，但latest之前的下载后没有ubuntu目录 # cd cluster/ubuntu # ll .. 2 root root 4096 Jan 8 17:39 default_scripts/ 各组件默认启动参数 .. 2 root root 4096 Jan 8 17:39 init_conf/ upstart启动方式 .. 2 root root 4096 Jan 8 17:39 initd_scripts/ service启动方式，与upstart选其一 .. 1 root root 1213 Jan 8 08:53 util.sh* # ./util.sh util.sh脚本就是把当前目录下的service/upstart脚本、默认参数配置文件复制到/etc下，可以通过service etcd start的形式管理kubernetes。由于kubernetes更新速度极快，项目的文件和目录结构经常变化，请找准文件。接下来我们需要修改那些只适合本机使用的默认参数。（请注意备份先，因为后面能否正常跨机器管理docker与这些选项有关，特别是IP）\netcd官方建议使用新的2379端口代替4001 # vi /etc/default/etcd ETCD_OPTS=\"-listen-client-urls=http://0.0.0.0:4001\" # vi /etc/default/kube-apiserver KUBE_APISERVER_OPTS=\"--address=0.0.0.0 \\ --port=8080 \\ --etcd_servers=http://127.0.0.1:4001 \\ --logtostderr=true \\ --portal_net=11.1.1.0/24\" # vi /etc/default/kube-scheduler KUBE_SCHEDULER_OPTS=\"--logtostderr=true \\ --master=127.0.0.1:8080\" # vi /etc/default/kube-controller-manager KUBE_CONTROLLER_MANAGER_OPTS=\"--master=127.0.0.1:8080 \\ --machines=172.29.88.207,172.29.88.208 \\ --logtostderr=true\" * 复制kubelet、kube-proxy等到minion1： # scp /etc/default/{kubelet,kube-proxy} 172.29.88.207:/etc/default/ # scp /etc/init.d/{kubelet,kube-proxy} 172.29.88.207:/etc/init.d/ # scp /etc/init/{kubelet.conf,kube-proxy.conf} 172.29.88.207:/etc/init/ * 在minion1端进行 # vi /etc/default/kubelet KUBELET_OPTS=\"--address=172.29.88.207 \\ --port=10250 \\ --hostname_override=172.29.88.207 \\ --etcd_servers=http://172.29.88.206:4001 \\ --logtostderr=true\" # vi /etc/default/kube-proxy KUBE_PROXY_OPTS=\"--etcd_servers=http://172.29.88.207:4001 \\ --logtostderr=true\" (对minion2重复上面 * 两个步骤，把上面.207改成.208) 上面的各配置文件就是对应命令的选项，具体含义使用-h。这里只简单说明：\netcd服务APIserver和minions都要访问，也就是其他组件的--etcd_servers值（带http前缀） kube-apiserver监听在8080端口，也就是其他组件的--master值；--portal_net地址段不能与docker的桥接网卡kbr0重复，指定docker容器的IP段 etcd、kube-apiserver、kube-scheduler、kube-controller-manager运行在apiserver（服务）端，kubelet、kube-proxy运行在minion（客户端） kube-controller-manager使用预先定义pod模板创建pods，保证指定数量的replicas在运行，默认监听在master的127.0.0.1:10252 kubelet默认监听端口10250，也正是apiserver的--kubelet_port的值 3.4 启动 重启docker 接下来重启minion1、minion2上的Docker daemon（注意使用的网桥）：\n# docker -d -b kbr0 由于后面的测试可能需要在线下载images，所以如果你的服务器无法访问docker hub，上面启动时记得设置HTTP_PROXY代理。\n启动apiserver\n# service etcd start # service kube-apiserver start kube-apiserver启动后会自动运行kube-scheduler、kube-controller-manager，但修改配置后依然可以单独重启各个服务如service kube-contoller-manager restart。这些服务的日志可以从/var/log/upstart/kube*找到。\n在minion1、minion2上启动kubelet、kube-proxy：\n# service kubelet start # service kube-proxy start 4. 使用kubecfg部署测试应用 为了方便，我们使用Kubernetes提供的例子Guestbook（下载的源码example目录下可以找到）来演示Kubernetes管理跨机器运行的容器，下面我们根据Guestbook的步骤创建容器及服务。在下面的过程中如果是第一次操作，可能会有一定的等待时间，状态处于pending，这是因为第一次下载images需要一段时间。\n4.1 创建redis-master Pod和redis-master服务 配置管理操作都在apiserver上执行，并且都是基于实现编写好的json格式。涉及到下载docker镜像的部分，如果没有外网，可能需要修改image的值或使用自己搭建的docker-registry：\n# cd kubernetes-0.7.2/examples/guestbook/ # cat redis-master.json { \"id\": \"redis-master\", \"kind\": \"Pod\", \"apiVersion\": \"v1beta1\", \"desiredState\": { \"manifest\": { \"version\": \"v1beta1\", \"id\": \"redis-master\", \"containers\": [{ \"name\": \"master\", \"image\": \"dockerfile/redis\", \"cpu\": 100, \"ports\": [{ \"containerPort\": 6379, \"hostPort\": 6379 }] }] } }, \"labels\": { \"name\": \"redis-master\" } } # kubecfg -h http://172.29.88.206:8080 -c redis-master.json create pods # kubecfg -h http://172.29.88.206:8080 -c redis-master-service.json create services 完成上面的操作后，我们可以看到如下redis-master Pod被调度到172.29.88.207： （下面直接list实际上是省略了-h http://127.0.0.1:8080）\n# kubecfg list pods Name Image(s) Host Labels Status ---------- ---------- ---------- ---------- ---------- redis-master dockerfile/redis 172.29.88.207/ name=redis-master Running 查看services： # kubecfg list services Name Labels Selector IP Port ---------- ---------- ---------- ---------- ------ kubernetes component=apiserver,provider=kubernetes 11.1.1.233 443 kubernetes-ro component=apiserver,provider=kubernetes 11.1.1.204 80 redis-master name=redis-master name=redis-master 11.1.1.175 6379 发现除了redis-master的服务之外，还有两个Kubernetes系统默认的服务kubernetes-ro和kubernetes。而且我们可以看到每个服务都有一个服务IP及相应的端口，对于服务IP，是一个虚拟地址，根据apiserver的portal_net选项设置的CIDR表示的IP地址段来选取，在我们的集群中设置为11.1.1.0/24。为此每新创建一个服务，apiserver都会在这个地址段中随机选择一个IP作为该服务的IP地址，而端口是事先确定的。对redis-master服务，其服务地址为11.1.1.175，端口为6379，与minion主机映射的端口也是6379。\n4.2 创建redis-slave Pod和redis-slave服务 # kubecfg -h http://172.29.88.206:8080 -c redis-slave-controller.json create replicationControllers # kubecfg -h http://172.29.88.206:8080 -c redis-slave-service.json create services 注意上面的redis-slave-controller.json有个\"replicas\": 2、\"hostPort\": 6380，因为我们的集群中只有2个minions，如果为3的话，就会导致有2个Pod会调度到同一台minion上，产生端口冲突，有一个Pod会一直处于pending状态，不能被调度（可以通过日志看到原因）。\n# kubecfg list pods Name Image(s) Host Labels Status ---------- ---------- ---------- ---------- -------- 2c2a06...c2971614d brendanburns/redis-slave 172.29.88.208/ name=redisslave,uses=redis-master Running 2c2ad5...c2971614d brendanburns/redis-slave 172.29.88.207/ name=redisslave,uses=redis-master Running redis-master dockerfile/redis 172.29.88.207/ name=redis-master Running # kubecfg list services Name Labels Selector IP Port ---------- ---------- ---------- ---------- -------- kubernetes component=apiserver,provider=kubernetes 11.1.1.233 443 kubernetes-ro component=apiserver,provider=kubernetes 11.1.1.204 80 redis-master name=redis-master name=redis-master 11.1.1.175 6379 redisslave name=redisslave name=redisslave 11.1.1.131 6379 4.3 创建Frontend Pod和Frontend服务 前面2步都是guestbook的redis数据存储，现在部署应用：(修改frontend-controller.json的replicas为2)\n# kubecfg -h http://172.29.88.206:8080 -c frontend-controller.json create replicationControllers # kubecfg -h http://172.29.88.206:8080 -c frontend-service.json create services # kubecfg -h http://172.29.88.206:8080 list pods Name Image(s) Host Labels Status ---------- ---------- ---------- ---------- ---------- 2c2a06...c2971614d brendanburns/redis-slave 172.29.88.208/ name=redisslave,uses=redis-master Running 2c2ad5...c2971614d brendanburns/redis-slave 172.29.88.207/ name=redisslave,uses=redis-master Running d87744...c2971614d kubernetes/example-guestbook-php-redis 172.29.88.207/ name=frontend,uses=redisslave,redis-master Running redis-master dockerfile/redis 172.29.88.207/ name=redis-master Running 1370b9...c2971614d kubernetes/example-guestbook-php-redis 172.29.88.208/ name=frontend,uses=redisslave,redis-master Running # kubecfg -h http://172.29.88.206:8080 list services Name Labels Selector IP Port ---------- ---------- ---------- ---------- ------ redis-master name=redis-master name=redis-master 11.1.1.175 6379 redisslave name=redisslave name=redisslave 11.1.1.131 6379 frontend name=frontend name=frontend 11.1.1.124 80 kubernetes component=apiserver,provider=kubernetes 11.1.1.233 443 kubernetes-ro component=apiserver,provider=kubernetes 11.1.1.204 80 通过查看可知 Frontend Pod 也被调度到两台minion，服务IP为11.1.1.124，端口是80，映射到外面minions的端口为8000（可以通过ps -ef|grep docker-proxy发现）。\n4.4 其他操作（更新、删除、查看） 删除 除此之外，你可以删除Pod、Service，如删除minion1上的redis-slave Pod：\nkubecfg -h http://172.29.88.206:8080 delete pods/2c2ad505-96fd-11e4-9c0b-000c2971614d Status ---------- Success 格式为services/服务Name、pods/pods名字，不必关心从哪个minion上删除了。需要提醒的是，这里pods的replcas为2，所以即使删除了这个pods，kubernetes为自动为你重新启动一个。\n更新 更新ReplicationController的Replicas数量：\n# kubecfg list replicationControllers Name Image(s) Selector Replicas ---------- ---------- ---------- ---------- frontendController kubernetes/example-guestbook-php-redis name=frontend 2 redisSlaveController brendanburns/redis-slave name=redisslave 2 把frontendController的Replicas更新为1，则这行如下命令，然后再通过上面的命令查看frontendController信息，发现Replicas已变为1：\nkubecfg -h http://172.29.88.206:8080 resize frontendController 1 查看 Kubernetes内置提供了一个简单的UI来查看pods、services、replicationControllers，但极其简陋，暂时可以忽略，访问http://172.29.88.206:8080/static/#/groups//selector/： 在浏览器访问api：http://172.29.88.206:8080/api/v1beta1/replicationControllers 。 etcd做服务发现，可以通过api访问其内容，访问http://172.29.88.206:4001/v2/keys/registry/services/endpoints/default ，得到json格式数据。\n4.5 演示guestbook 通过上面的结果可知当前提供前端服务的PHP和提供数据存储的后端服务Redis master的Pod分别运行在172.29.88.208和172.29.88.207上，即容器运行在不同主机上，还有Redis slave也运行在两台不同的主机上，它会从Redis master同步前端写入Redis master的数据。下面我们从两方面验证Kubernetes能提供跨机器间容器的通信：\n浏览器访问留言簿 在浏览器打开http://${IPAddress}:8000，IPAddress为PHP容器运行的minion的IP地址，其暴漏的端口为8000，这里IP_Address为172.29.88.208。打开浏览器会显示如下信息： 你可以输入信息并提交，然后Submit按钮下方会显示你输入的信息： 由于前端PHP容器和后端Redis master容器分别在两台minion上，因此PHP在访问Redis master服务时一定得跨机器通信，可见Kubernetes的实现方式避免了用link只能在同一主机上实现容器间通信的缺陷。\n从redis后端验证 我们从后端数据层验证不同机器容器间的通信。根据上面的输出结果发现Redis slave和Redis master分别调度到两台不同的minion上，在172.29.88.207主机上执行docker exec -ti e5941db7e424 /bin/sh，e5941db7e424 master的容器ID（docker ps），进入容器后通过redis-cli命令查看从浏览器输入的信息如下：\n# docker exec -ti e5941db7e424 /bin/sh # redis-cli 127.0.0.1:6379\u003e keys * 1) \"messages\" 127.0.0.1:6379\u003e get messages \",Hi, Sean,Kubernetes,,llll,abc,\\xef\\xbf\\xbd\\xef\\xbf\\xbd\\xef\\xbf\\xbd\\xd4\\xb0\\xef\\xbf\\xbd,sync info,\" 类似可以在172.29.88.208的redis-slave上看到同样的内容。由此可见Redis master和Redis slave之间数据同步正常，OVS GRE隧道技术使得跨机器间容器正常通信。\n4.6 排错提示 所有的kubelet必须起来，否则报错F0319 16:56:08.058335 9960 kubecfg.go:438] Got request error: The requested resource does not exist. 必须使用-b启动docker，否则无法访问8000端口，redis-slave也没同步 注意pods一直处于Pending或Failed状态时去apiserver或其他组件日志里查看错误，是否是由于端口绑定冲突导致。 参考\nCentOS 7实战Kubernetes部署\nkubernetes-examples-guestbook\ngetting_started_guides-ubuntu_single_node\n基于kubernetes构建Docker集群管理详解\n",
  "wordCount" : "980",
  "inLanguage": "en",
  "datePublished": "2015-02-07T13:21:25Z",
  "dateModified": "2015-02-07T13:21:25Z",
  "author":{
    "@type": "Person",
    "name": "admin"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://xgknight.com/posts/2015/02/%E5%9C%A8ubuntu%E4%B8%8A%E9%83%A8%E7%BD%B2kubernetes%E7%AE%A1%E7%90%86docker%E9%9B%86%E7%BE%A4%E7%A4%BA%E4%BE%8B/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sean Note",
    "logo": {
      "@type": "ImageObject",
      "url": "http://xgknight.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://xgknight.com/" accesskey="h" title="Sean Note (Alt + H)">Sean Note</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://xgknight.com/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://xgknight.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      在ubuntu上部署Kubernetes管理docker集群示例
    </h1>
    <div class="post-meta"><span title='2015-02-07 13:21:25 +0000 UTC'>February 7, 2015</span>&nbsp;·&nbsp;admin

</div>
  </header> 
  <div class="post-content"><p>本文通过实际操作来演示Kubernetes的使用，因为环境有限，集群部署在本地3个ubuntu上，主要包括如下内容：</p>
<ul>
<li>部署环境介绍，以及Kubernetes集群逻辑架构</li>
<li>安装部署Open vSwitch跨机器容器通信工具</li>
<li>安装部署Etcd和Kubernetes的各大组件</li>
<li>演示Kubernetes管理容器和服务</li>
</ul>
<p>关于 Kubernetes 系统架构及组件介绍见<a href="http://xgknight.com/2015/02/03/docker-kubernetes-arch-introduction/">这里</a>。</p>
<h1 id="1-部署环境及架构">1. 部署环境及架构<a hidden class="anchor" aria-hidden="true" href="#1-部署环境及架构">#</a></h1>
<ul>
<li>vSphere: 5.1</li>
<li>操作系统: ubuntu 14.04 x86_64</li>
<li>Open vSwith版本: 2.0.2</li>
<li>Kubernetes: v0.7.2</li>
<li>Etcd版本: 2.0.0-rc.1</li>
<li>Docker版本: 1.4.1</li>
<li>服务器信息：</li>
</ul>
<table>
<thead>
<tr>
<th>Role</th>
<th>Hostname</th>
<th>IP Address</th>
</tr>
</thead>
<tbody>
<tr>
<td>APIServer</td>
<td>kubernetes</td>
<td>172.29.88.206</td>
</tr>
<tr>
<td>Minion</td>
<td>minion1</td>
<td>172.29.88.207</td>
</tr>
<tr>
<td>Minion</td>
<td>minion2</td>
<td>172.29.88.208</td>
</tr>
</tbody>
</table>
<p>在详细介绍部署Kubernetes集群前，先给大家展示下集群的逻辑架构。从下图可知，整个系统分为两部分，第一部分是Kubernetes APIServer，是整个系统的核心，承担集群中所有容器的管理工作；第二部分是minion，运行Container Daemon，是所有容器栖息之地，同时在minion上运行Open vSwitch程序，通过GRE Tunnel负责minions之间Pod的网络通信工作。
<img loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/kubernetes-deploy.png" alt="kubernetes-deploy"  />
</p>
<!-- raw HTML omitted -->
<h1 id="2-安装open-vswitch及配置gre">2. 安装Open vSwitch及配置GRE<a hidden class="anchor" aria-hidden="true" href="#2-安装open-vswitch及配置gre">#</a></h1>
<p>为了解决跨minion之间Pod的通信问题，我们在每个minion上安装Open vSwtich，并使用GRE或者VxLAN使得跨机器之间P11od能相互通信，本文使用GRE，而VxLAN通常用在需要隔离的大规模网络中。对于Open vSwitch的介绍请参考另一篇文章<a href="http://">Open vSwitch</a>。</p>
<pre tabindex="0"><code>sudo apt-get install openvswitch-switch bridge-utils
</code></pre><p>安装完Open vSwitch和桥接工具后，接下来便建立minion0和minion1之间的隧道。首先在minion1和minion2上分别建立OVS Bridge：</p>
<pre tabindex="0"><code># ovs-vsctl add-br obr0
</code></pre><p>接下来建立gre，并将新建的gre0添加到obr0，在minion1上执行如下命令：</p>
<pre tabindex="0"><code># ovs-vsctl add-port obr0 gre0 -- set Interface gre0 type=gre options:remote_ip=172.29.88.208
</code></pre><p>上面的remoute_ip是另一台服务minion2上的对外IP。</p>
<p>在minion2上执行：</p>
<pre tabindex="0"><code># ovs-vsctl add-port obr0 gre0 -- set Interface gre0 type=gre options:remote_ip=172.29.88.207
</code></pre><p>至此，minion1和minion2之间的隧道已经建立。然后我们在minion1和minion2上创建Linux网桥kbr0替代Docker默认的docker0（我们假设minion1和minion2都已安装Docker），设置minion1的kbr0的地址为172.17.1.1/24， minion2的kbr0的地址为172.17.2.1/24，并添加obr0为kbr0的接口，以下命令在minion1和minion2上执行：</p>
<pre tabindex="0"><code># brctl addbr kbr0              //创建linux bridge代替docker0
# brctl addif kbr0 obr0         //添加obr0为kbr0的接口

# ip link set dev docker0 down  //设置docker0为down状态
# ip link del dev docker0       //删除docker0，可选
</code></pre><p>查看这些接口的状态：</p>
<pre tabindex="0"><code># service openvswitch-switch status
# ovs-vsctl show
9d248403-943c-41c0-b2d0-3f9b130cdd3f
    Bridge &#34;obr0&#34;
        Port &#34;gre0&#34;
            Interface &#34;gre0&#34;
                type: gre
                options: {remote_ip=&#34;172.29.88.207&#34;}
        Port &#34;obr0&#34;
            Interface &#34;obr0&#34;
                type: internal
    ovs_version: &#34;2.0.2&#34;

# brctl show
bridge name	bridge id		STP enabled	interfaces
docker0		8000.56847afe9799	no		
kbr0		8000.620ff7ee9c49	no		obr0
</code></pre><p>为了使新建的kbr0在每次系统重启后任然有效，我们在minion1的<code>/etc/network/interfaces</code>文件中追加内容如下：（在CentOS上会有些不一样）</p>
<pre tabindex="0"><code># vi /etc/network/interfaces
auto kbr0
iface kbr0 inet static
        address 172.17.1.1
        netmask 255.255.255.0
        gateway 172.17.1.0
        dns-nameservers 172.31.1.1
</code></pre><p>同样在minion2上追加类似内容，只需修改address为172.17.2.1和gateway为172.17.2.0即可，然后执行<code>ip link set dev kbr0 up</code>，你能在minion1和minion2上发现kbr0都设置了相应的IP地址。为了验证我们创建的隧道是否能通信，我们在minion1和minion2上相互ping对方kbr0的IP地址，从下面的结果发现是不通的，经查找这是因为在minion1和minion2上缺少访问172.17.1.1和172.17.2.1的路由，因此我们需要添加路由保证彼此之间能通信：</p>
<pre tabindex="0"><code>minion1上执行:
# ip route add 172.17.2.0/24 via 172.29.88.208 dev eth0

minion2上执行:
# ip route add 172.17.1.0/24 via 172.29.88.207 dev eth0
</code></pre><p>现在可以ping通对方的虚拟网络了：</p>
<pre tabindex="0"><code>$ ping 172.17.2.1
PING 172.17.2.1 (172.17.2.1) 56(84) bytes of data.
64 bytes from 172.17.2.1: icmp_seq=1 ttl=64 time=0.334 ms
64 bytes from 172.17.2.1: icmp_seq=2 ttl=64 time=0.253 ms
^C
--- 172.17.2.1 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 999ms
rtt min/avg/max/mdev = 0.253/0.293/0.334/0.043 ms
</code></pre><p>下面安装 Kubernetes APIServer 及kubelet、proxy等服务。</p>
<h1 id="3-安装kubernetes-apiserver">3. 安装Kubernetes APIServer<a hidden class="anchor" aria-hidden="true" href="#3-安装kubernetes-apiserver">#</a></h1>
<h2 id="31-下载安装kubernetes各组件">3.1 下载安装kubernetes各组件<a hidden class="anchor" aria-hidden="true" href="#31-下载安装kubernetes各组件">#</a></h2>
<p>可以自己从源码编译kubernetes（需要安装golang环境），也可以从<a href="https://github.com/GoogleCloudPlatform/kubernetes/releases">GitHub Kubernetes repo release page.</a>选择编译好的二进制版本（v0.7.2）下载，为了方便后面启动或关闭kubernetes组件，我们同时下载二进制包和源码包：</p>
<pre tabindex="0"><code># cd /usr/local/src
# wget https://github.com/coreos/etcd/releases/download/v2.0.0-rc.1/etcd-v2.0.0-rc.1-linux-amd64.tar.gz
# wget https://github.com/GoogleCloudPlatform/kubernetes/releases/download/v0.7.2/kubernetes.tar.gz
# wget https://github.com/GoogleCloudPlatform/kubernetes/archive/v0.7.2.zip
</code></pre><p>然后解压下载的kubernetes和etcd包，并在kubernetes(minion1)、minion2上创建目录<code>/opt/bin</code></p>
<pre tabindex="0"><code># mkdir /opt/bin        //这一步APIserver和所有minions上都要创建

解压kubernetes
src# tar xf kubernetes.tar.gz
# ll 
drwxr-xr-x  3  501 staff     4096 Dec 19 02:32 etcd-v2.0.0-rc.1-linux-amd64/
-rw-r--r--  1 root root   6223584 Jan  6 14:39 etcd-v2.0.0-rc.1-linux-amd64.tar.gz
drwxr-xr-x  7 root root      4096 Nov 20 06:35 kubernetes/
-rw-r--r--  1 root root  82300483 Jan  6 14:37 kubernetes.tar.gz
-rw-r--r--  1 root root  9170754 Jan  9 14:47 v0.7.2.zip

# cd kubernetes/server
# tar xf kubernetes-server-linux-amd64.tar.gz
# cd kubernetes/server/bin/

APIserver本身需要的是kube-apiserver kube-scheduler kube-controller-manager kubecfg四个
# cp -a kube* /opt/bin/

把proxy和kubelet复制到其他minions，确保这些文件都是可执行的
# scp kube-proxy kubelet root@172.29.88.207:/opt/bin
# scp kube-proxy kubelet root@172.29.88.208:/opt/bin
</code></pre><p><code>/opt/bin</code>并没有加入系统<code>PATH</code>，所以<code>kube-apiserver -version</code>是看不到结果，但在后面配置的服务中会自动加入（<code>PATH=$PATH:/opt/bin</code>）。</p>
<h2 id="32-解压安装etcd">3.2 解压安装etcd<a hidden class="anchor" aria-hidden="true" href="#32-解压安装etcd">#</a></h2>
<p><code>etcd</code>在这里的作用是服务发现存储仓库，通俗的来讲就是记录kubernetes启动了多少pods、services、replicationController以及它们的信息等，详细介绍见<a href="http//">这里</a>。此外版本2.0与v0.4.6在启动参数上的写法有一定差别。</p>
<pre><code># tar xf etcd-v2.0.0-rc.1-linux-amd64.tar.gz &amp;&amp; cd etcd-v2.0.0-rc.1-linux-amd64/
# cp -a etcd etcdctl /opt/bin
</code></pre>
<h2 id="33-配置kube-apiserver等为upstart脚本启动">3.3 配置kube-apiserver等为upstart脚本启动<a hidden class="anchor" aria-hidden="true" href="#33-配置kube-apiserver等为upstart脚本启动">#</a></h2>
<p>这一步主要是为了管理kube-apiserver等进程的方便，避免每次都手动启动各服务、添加冗长的启动参数选项，而且在不同的系统平台下kubernetes已经提供了相应的工具。</p>
<pre tabindex="0"><code>解压kubernetes*源码包*
src# unzip xf v0.7.2.zip &amp;&amp; cd kubernetes-0.7.2

这里比较奇怪的是最新release版本源码的cluster目录下是有ubuntu子目录的，但latest之前的下载后没有ubuntu目录
# cd cluster/ubuntu
# ll
.. 2 root root 4096 Jan  8 17:39 default_scripts/   各组件默认启动参数
.. 2 root root 4096 Jan  8 17:39 init_conf/         upstart启动方式
.. 2 root root 4096 Jan  8 17:39 initd_scripts/     service启动方式，与upstart选其一
.. 1 root root 1213 Jan  8 08:53 util.sh*     

# ./util.sh
</code></pre><p><code>util.sh</code>脚本就是把当前目录下的service/upstart脚本、默认参数配置文件复制到<code>/etc</code>下，可以通过<code>service etcd start</code>的形式管理kubernetes。由于kubernetes更新速度极快，项目的文件和目录结构经常变化，请找准文件。接下来我们需要修改那些只适合本机使用的默认参数。（请注意备份先，因为后面能否正常跨机器管理docker与这些选项有关，特别是IP）</p>
<pre tabindex="0"><code>etcd官方建议使用新的2379端口代替4001
# vi /etc/default/etcd
ETCD_OPTS=&#34;-listen-client-urls=http://0.0.0.0:4001&#34;

# vi /etc/default/kube-apiserver
KUBE_APISERVER_OPTS=&#34;--address=0.0.0.0 \
--port=8080 \
--etcd_servers=http://127.0.0.1:4001 \
--logtostderr=true \
--portal_net=11.1.1.0/24&#34;

# vi /etc/default/kube-scheduler
KUBE_SCHEDULER_OPTS=&#34;--logtostderr=true \
--master=127.0.0.1:8080&#34;

# vi /etc/default/kube-controller-manager
KUBE_CONTROLLER_MANAGER_OPTS=&#34;--master=127.0.0.1:8080 \
--machines=172.29.88.207,172.29.88.208 \
--logtostderr=true&#34;


* 复制kubelet、kube-proxy等到minion1：
# scp /etc/default/{kubelet,kube-proxy} 172.29.88.207:/etc/default/
# scp /etc/init.d/{kubelet,kube-proxy} 172.29.88.207:/etc/init.d/
# scp /etc/init/{kubelet.conf,kube-proxy.conf} 172.29.88.207:/etc/init/
</code></pre><pre tabindex="0"><code>* 在minion1端进行
# vi /etc/default/kubelet
KUBELET_OPTS=&#34;--address=172.29.88.207 \
--port=10250 \
--hostname_override=172.29.88.207 \
--etcd_servers=http://172.29.88.206:4001 \
--logtostderr=true&#34;

# vi /etc/default/kube-proxy
KUBE_PROXY_OPTS=&#34;--etcd_servers=http://172.29.88.207:4001 \
--logtostderr=true&#34;

(对minion2重复上面 * 两个步骤，把上面.207改成.208)
</code></pre><p>上面的各配置文件就是对应命令的选项，具体含义使用<code>-h</code>。这里只简单说明：</p>
<ol>
<li><code>etcd</code>服务APIserver和minions都要访问，也就是其他组件的<code>--etcd_servers</code>值（带http前缀）</li>
<li><code>kube-apiserver</code>监听在8080端口，也就是其他组件的<code>--master</code>值；<code>--portal_net</code>地址段不能与docker的桥接网卡kbr0重复，指定docker容器的IP段</li>
<li><code>etcd</code>、<code>kube-apiserver</code>、<code>kube-scheduler</code>、<code>kube-controller-manager</code>运行在apiserver（服务）端，<code>kubelet</code>、<code>kube-proxy</code>运行在minion（客户端）</li>
<li><code>kube-controller-manager</code>使用预先定义pod模板创建pods，保证指定数量的replicas在运行，默认监听在master的127.0.0.1:10252</li>
<li><code>kubelet</code>默认监听端口10250，也正是apiserver的<code>--kubelet_port</code>的值</li>
</ol>
<h2 id="34-启动">3.4 启动<a hidden class="anchor" aria-hidden="true" href="#34-启动">#</a></h2>
<p><strong>重启docker</strong>
接下来重启minion1、minion2上的Docker daemon（注意使用的网桥）：</p>
<pre><code># docker -d -b kbr0
</code></pre>
<p>由于后面的测试可能需要在线下载images，所以如果你的服务器无法访问docker hub，上面启动时记得设置<code>HTTP_PROXY</code>代理。</p>
<p><strong>启动apiserver</strong></p>
<pre><code># service etcd start
# service kube-apiserver start
</code></pre>
<p><code>kube-apiserver</code>启动后会自动运行<code>kube-scheduler</code>、<code>kube-controller-manager</code>，但修改配置后依然可以单独重启各个服务如<code>service kube-contoller-manager restart</code>。这些服务的日志可以从<code>/var/log/upstart/kube*</code>找到。</p>
<p><strong>在minion1、minion2上启动kubelet、kube-proxy</strong>：</p>
<pre><code># service kubelet start
# service kube-proxy start
</code></pre>
<h1 id="4-使用kubecfg部署测试应用">4. 使用kubecfg部署测试应用<a hidden class="anchor" aria-hidden="true" href="#4-使用kubecfg部署测试应用">#</a></h1>
<p>为了方便，我们使用Kubernetes提供的例子<a href="https://github.com/GoogleCloudPlatform/kubernetes/tree/master/examples/guestbook">Guestbook</a>（下载的源码example目录下可以找到）来演示Kubernetes管理跨机器运行的容器，下面我们根据Guestbook的步骤创建容器及服务。在下面的过程中如果是第一次操作，可能会有一定的等待时间，状态处于pending，这是因为第一次下载images需要一段时间。</p>
<h2 id="41-创建redis-master-pod和redis-master服务">4.1 创建redis-master Pod和redis-master服务<a hidden class="anchor" aria-hidden="true" href="#41-创建redis-master-pod和redis-master服务">#</a></h2>
<p>配置管理操作都在apiserver上执行，并且都是基于实现编写好的json格式。涉及到下载docker镜像的部分，如果没有外网，可能需要修改image的值或使用自己搭建的docker-registry：</p>
<pre tabindex="0"><code># cd kubernetes-0.7.2/examples/guestbook/
# cat redis-master.json
{
  &#34;id&#34;: &#34;redis-master&#34;,
  &#34;kind&#34;: &#34;Pod&#34;,
  &#34;apiVersion&#34;: &#34;v1beta1&#34;,
  &#34;desiredState&#34;: {
    &#34;manifest&#34;: {
      &#34;version&#34;: &#34;v1beta1&#34;,
      &#34;id&#34;: &#34;redis-master&#34;,
      &#34;containers&#34;: [{
        &#34;name&#34;: &#34;master&#34;,
        &#34;image&#34;: &#34;dockerfile/redis&#34;,
        &#34;cpu&#34;: 100,
        &#34;ports&#34;: [{
          &#34;containerPort&#34;: 6379,
          &#34;hostPort&#34;: 6379
        }]
      }]
    }
  },
  &#34;labels&#34;: {
    &#34;name&#34;: &#34;redis-master&#34;
  }
}

# kubecfg -h http://172.29.88.206:8080 -c redis-master.json create pods
# kubecfg -h http://172.29.88.206:8080 -c redis-master-service.json create services
</code></pre><p>完成上面的操作后，我们可以看到如下redis-master Pod被调度到172.29.88.207：
（下面直接list实际上是省略了<code>-h http://127.0.0.1:8080</code>）</p>
<pre tabindex="0"><code># kubecfg list pods
Name             Image(s)            Host               Labels              Status
----------       ----------          ----------         ----------          ----------
redis-master     dockerfile/redis    172.29.88.207/     name=redis-master   Running

查看services：
# kubecfg list services
Name            Labels                                    Selector            IP            Port
----------      ----------                                ----------          ----------    ------
kubernetes      component=apiserver,provider=kubernetes                       11.1.1.233    443
kubernetes-ro   component=apiserver,provider=kubernetes                       11.1.1.204    80
redis-master    name=redis-master                         name=redis-master   11.1.1.175    6379
</code></pre><p>发现除了redis-master的服务之外，还有两个Kubernetes系统默认的服务kubernetes-ro和kubernetes。而且我们可以看到每个服务都有一个服务IP及相应的端口，对于服务IP，是一个虚拟地址，根据apiserver的<code>portal_net</code>选项设置的<code>CIDR</code>表示的IP地址段来选取，在我们的集群中设置为11.1.1.0/24。为此每新创建一个服务，apiserver都会在这个地址段中随机选择一个IP作为该服务的IP地址，而端口是事先确定的。对redis-master服务，其服务地址为11.1.1.175，端口为6379，与minion主机映射的端口也是6379。</p>
<h2 id="42-创建redis-slave-pod和redis-slave服务">4.2 创建redis-slave Pod和redis-slave服务<a hidden class="anchor" aria-hidden="true" href="#42-创建redis-slave-pod和redis-slave服务">#</a></h2>
<pre tabindex="0"><code># kubecfg -h http://172.29.88.206:8080 -c redis-slave-controller.json create replicationControllers
# kubecfg -h http://172.29.88.206:8080 -c redis-slave-service.json create services
</code></pre><p>注意上面的<code>redis-slave-controller.json</code>有个<code>&quot;replicas&quot;: 2</code>、<code>&quot;hostPort&quot;: 6380</code>，因为我们的集群中只有2个minions，如果为3的话，就会导致有2个Pod会调度到同一台minion上，产生端口冲突，有一个Pod会一直处于pending状态，不能被调度（可以通过日志看到原因）。</p>
<pre tabindex="0"><code># kubecfg list pods
Name                 Image(s)                     Host             Labels                                       Status
----------           ----------                   ----------       ----------                                   --------
2c2a06...c2971614d   brendanburns/redis-slave     172.29.88.208/   name=redisslave,uses=redis-master            Running
2c2ad5...c2971614d   brendanburns/redis-slave     172.29.88.207/   name=redisslave,uses=redis-master            Running
redis-master         dockerfile/redis             172.29.88.207/   name=redis-master                            Running

# kubecfg list services
Name              Labels                                    Selector            IP                  Port
----------        ----------                                ----------          ----------          --------
kubernetes        component=apiserver,provider=kubernetes                       11.1.1.233          443
kubernetes-ro     component=apiserver,provider=kubernetes                       11.1.1.204          80
redis-master      name=redis-master                         name=redis-master   11.1.1.175          6379
redisslave        name=redisslave                           name=redisslave     11.1.1.131          6379
</code></pre><h2 id="43-创建frontend-pod和frontend服务">4.3 创建Frontend Pod和Frontend服务<a hidden class="anchor" aria-hidden="true" href="#43-创建frontend-pod和frontend服务">#</a></h2>
<p>前面2步都是guestbook的redis数据存储，现在部署应用：(修改<code>frontend-controller.json</code>的<code>replicas</code>为2)</p>
<pre tabindex="0"><code># kubecfg -h http://172.29.88.206:8080 -c frontend-controller.json create replicationControllers
# kubecfg -h http://172.29.88.206:8080 -c frontend-service.json create services
</code></pre><pre tabindex="0"><code># kubecfg -h http://172.29.88.206:8080 list pods
Name                 Image(s)                                 Host              Labels                                       Status
----------           ----------                               ----------        ----------                                   ----------
2c2a06...c2971614d   brendanburns/redis-slave                 172.29.88.208/    name=redisslave,uses=redis-master            Running
2c2ad5...c2971614d   brendanburns/redis-slave                 172.29.88.207/    name=redisslave,uses=redis-master            Running
d87744...c2971614d   kubernetes/example-guestbook-php-redis   172.29.88.207/    name=frontend,uses=redisslave,redis-master   Running
redis-master         dockerfile/redis                         172.29.88.207/    name=redis-master                            Running
1370b9...c2971614d   kubernetes/example-guestbook-php-redis   172.29.88.208/    name=frontend,uses=redisslave,redis-master   Running

# kubecfg -h http://172.29.88.206:8080 list services
Name             Labels                                    Selector            IP            Port
----------       ----------                                ----------          ----------    ------
redis-master     name=redis-master                         name=redis-master   11.1.1.175    6379
redisslave       name=redisslave                           name=redisslave     11.1.1.131    6379
frontend         name=frontend                             name=frontend       11.1.1.124    80
kubernetes       component=apiserver,provider=kubernetes                       11.1.1.233    443
kubernetes-ro    component=apiserver,provider=kubernetes                       11.1.1.204    80
</code></pre><p>通过查看可知 Frontend Pod 也被调度到两台minion，服务IP为11.1.1.124，端口是80，映射到外面minions的端口为8000（可以通过<code>ps -ef|grep docker-proxy</code>发现）。</p>
<h2 id="44-其他操作更新删除查看">4.4 其他操作（更新、删除、查看）<a hidden class="anchor" aria-hidden="true" href="#44-其他操作更新删除查看">#</a></h2>
<p><strong>删除</strong>
除此之外，你可以删除Pod、Service，如删除minion1上的redis-slave Pod：</p>
<pre><code>kubecfg -h http://172.29.88.206:8080 delete pods/2c2ad505-96fd-11e4-9c0b-000c2971614d
Status
----------
Success
</code></pre>
<p>格式为<code>services/服务Name</code>、<code>pods/pods名字</code>，不必关心从哪个minion上删除了。需要提醒的是，这里pods的replcas为2，所以即使删除了这个pods，kubernetes为自动为你重新启动一个。</p>
<p><strong>更新</strong>
更新ReplicationController的Replicas数量：</p>
<pre tabindex="0"><code># kubecfg list replicationControllers
Name                   Image(s)                                 Selector            Replicas
----------             ----------                               ----------          ----------
frontendController     kubernetes/example-guestbook-php-redis   name=frontend       2
redisSlaveController   brendanburns/redis-slave                 name=redisslave     2
</code></pre><p>把frontendController的Replicas更新为1，则这行如下命令，然后再通过上面的命令查看frontendController信息，发现Replicas已变为1：</p>
<pre><code>kubecfg -h http://172.29.88.206:8080 resize frontendController 1
</code></pre>
<p><strong>查看</strong>
Kubernetes内置提供了一个简单的UI来查看pods、services、replicationControllers，但极其简陋，暂时可以忽略，访问<code>http://172.29.88.206:8080/static/#/groups//selector/</code>：
<img loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/kubernetes-simpleui.png" alt="kubernetes-simpleui"  />
</p>
<p>在浏览器访问api：<code>http://172.29.88.206:8080/api/v1beta1/replicationControllers</code> 。
<img loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/kubernetes-api.png" alt="kubernetes-api"  />
</p>
<p>etcd做服务发现，可以通过api访问其内容，访问<code>http://172.29.88.206:4001/v2/keys/registry/services/endpoints/default</code> ，得到json格式数据。</p>
<h2 id="45-演示guestbook">4.5 演示guestbook<a hidden class="anchor" aria-hidden="true" href="#45-演示guestbook">#</a></h2>
<p>通过上面的结果可知当前提供前端服务的PHP和提供数据存储的后端服务Redis master的Pod分别运行在172.29.88.208和172.29.88.207上，即容器运行在不同主机上，还有Redis slave也运行在两台不同的主机上，它会从Redis master同步前端写入Redis master的数据。下面我们从两方面验证Kubernetes能提供跨机器间容器的通信：</p>
<p><strong>浏览器访问留言簿</strong>
在浏览器打开<code>http://${IPAddress}:8000</code>，IPAddress为PHP容器运行的minion的IP地址，其暴漏的端口为8000，这里IP_Address为172.29.88.208。打开浏览器会显示如下信息：
<img loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/kubernetes-guestbook1.png" alt="kubernetes-guestbook1"  />
</p>
<p>你可以输入信息并提交，然后Submit按钮下方会显示你输入的信息：
<img loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/kubernetes-guestbook2.png" alt="kubernetes-guestbook2"  />

由于前端PHP容器和后端Redis master容器分别在两台minion上，因此PHP在访问Redis master服务时一定得跨机器通信，可见Kubernetes的实现方式避免了用link只能在同一主机上实现容器间通信的缺陷。</p>
<p><strong>从redis后端验证</strong>
我们从后端数据层验证不同机器容器间的通信。根据上面的输出结果发现Redis slave和Redis master分别调度到两台不同的minion上，在172.29.88.207主机上执行<code>docker exec -ti e5941db7e424 /bin/sh</code>，e5941db7e424 master的容器ID（<code>docker ps</code>），进入容器后通过redis-cli命令查看从浏览器输入的信息如下：</p>
<pre tabindex="0"><code># docker exec -ti e5941db7e424 /bin/sh
# redis-cli
127.0.0.1:6379&gt; keys *
1) &#34;messages&#34;
127.0.0.1:6379&gt; get messages
&#34;,Hi, Sean,Kubernetes,,llll,abc,\xef\xbf\xbd\xef\xbf\xbd\xef\xbf\xbd\xd4\xb0\xef\xbf\xbd,sync info,&#34;
</code></pre><p>类似可以在172.29.88.208的redis-slave上看到同样的内容。由此可见Redis master和Redis slave之间数据同步正常，OVS GRE隧道技术使得跨机器间容器正常通信。</p>
<h2 id="46-排错提示">4.6 排错提示<a hidden class="anchor" aria-hidden="true" href="#46-排错提示">#</a></h2>
<ol>
<li>所有的kubelet必须起来，否则报错<code>F0319 16:56:08.058335    9960 kubecfg.go:438] Got request error: The requested resource does not exist.</code></li>
<li>必须使用-b启动docker，否则无法访问8000端口，redis-slave也没同步</li>
<li>注意pods一直处于Pending或Failed状态时去apiserver或其他组件日志里查看错误，是否是由于端口绑定冲突导致。</li>
</ol>
<p><strong>参考</strong></p>
<ul>
<li>
<p><a href="http://www.infoq.com/cn/articles/centos7-practical-kubernetes-deployment">CentOS 7实战Kubernetes部署</a></p>
</li>
<li>
<p><a href="https://github.com/GoogleCloudPlatform/kubernetes/tree/master/examples/guestbook">kubernetes-examples-guestbook</a></p>
</li>
<li>
<p><a href="https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/getting-started-guides/ubuntu_single_node.md">getting_started_guides-ubuntu_single_node</a></p>
</li>
<li>
<p><a href="http://blog.liuts.com/category/42/1/1/">基于kubernetes构建Docker集群管理详解</a></p>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://xgknight.com/tags/docker/">docker</a></li>
      <li><a href="http://xgknight.com/tags/linux/">linux</a></li>
      <li><a href="http://xgknight.com/tags/kubernetes/">kubernetes</a></li>
    </ul>
  </footer><script src="https://utteranc.es/client.js"
        repo="seanlook/sean-notes-comment"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="http://xgknight.com/">Sean Note</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
