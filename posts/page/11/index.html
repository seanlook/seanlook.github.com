<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | Sean Note</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - Sean Note">
<meta name="author" content="admin">
<link rel="canonical" href="http://xgknight.com/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css" integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://xgknight.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://xgknight.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://xgknight.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://xgknight.com/apple-touch-icon.png">
<link rel="mask-icon" href="http://xgknight.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://xgknight.com/posts/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://xgknight.com/posts/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://xgknight.com/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://xgknight.com/" accesskey="h" title="Sean Note (Alt + H)">Sean Note</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://xgknight.com/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://xgknight.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>搭建docker内网私服（docker-registry with nginx&amp;ssl on centos）
    </h2>
  </header>
  <div class="entry-content">
    <p>主要思路： 1. Docker Registry 说明 关于如何创建和使用本地仓库，其实已经有很多文章介绍了。因为docker技术正处于发展和完善阶段，所以有些文章要么内容已经过时，要么给出了错误的配置，导致无法正常创建仓库。本文记录的是个人完整的搭建过程，docker version为1.1.2。
官方提供了Docker Hub网站来作为一个公开的集中仓库。然而，本地访问Docker Hub速度往往很慢，并且很多时候我们需要一个本地的私有仓库只供网内使用。
Docker仓库实际上提供两方面的功能，一个是镜像管理，一个是认证。前者主要由docker-registry项目来实现，通过http服务来上传下载；后者可以通过docker-index（闭源）项目或者利用现成认证方案（如nginx）实现http请求管理。
docker-registry既然也是软件应用，自然最简单的方法就是使用官方提供的已经部署好的镜像registry。官方文档中也给出了建议，直接运行sudo docker run -p 5000:5000 registry命令。这样确实能启动一个registry服务器，但是所有上传的镜像其实都是由docker容器管理，放在了/var/lib/docker/….某个目录下。而且一旦删除容器，镜像也会被删除。因此，我们需要想办法告诉docker容器镜像应该存放在哪里。registry镜像中启动后镜像默认位置是/tmp/registry，因此直接映射这个位置即可，比如到本机的/opt/data/registry目录下。
2. 在CentOS上搭建docker私服 2.1 安装docker-registry 方法有多种，直接运行下面的命令：
# docker run -d -e SETTINGS_FLAVOR=dev -e STORAGE_PATH=/tmp/registry -v /opt/data/registry:/tmp/registry -p 5000:5000 registry 如果本地没有拉取过docker-registry，则首次运行会pull registry，运行时会映射路径和端口，以后就可以从/opt/data/registry下找到私有仓库都存在哪些镜像，通过主机的哪个端口可以访问。 你也可以把项目 https://github.com/docker/docker-registry.git 克隆到本地，然后使用Dockerfile来build镜像：
# git clone https://github.com/docker/docker-registry.git # cd docker-registry &amp;&amp; mkdir -p /opt/data/registry # docker build -t &#34;local-sean&#34; . build完成后，就可以运行这个docker-registry 我们先配置自己的config.yml文件，第一种方法是直接在run的时候指定变量 # cp config/config_sample.yml /opt/data/registry/config.yml # vi /opt/data/registry/config.yml ##这里可以设置本地存储SETTINGS_FLAVOR=dev，local STORAGE_PATH:/tmp/registry等待 # docker run -d -v /opt/data/registry:/tmp/registry -p 5000:5000 -e DOCKER_REGISTRY_CONFIG=/tmp/registry/config....</p>
  </div>
  <footer class="entry-footer"><span title='2014-11-13 20:21:25 +0000 UTC'>November 13, 2014</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to 搭建docker内网私服（docker-registry with nginx&amp;ssl on centos）" href="http://xgknight.com/posts/2014/11/%E6%90%AD%E5%BB%BAdocker%E5%86%85%E7%BD%91%E7%A7%81%E6%9C%8Ddocker-registry-with-nginxssl-on-centos/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>完全解决Github Pages邮件两次warning（DNS解析问题）
    </h2>
  </header>
  <div class="entry-content">
    <p>之所以有本文是由于Github前后两次发了2封不同的警告邮件，都是关于DNS配置的。因为xgknight.com刚申请下来时我也是参考其他博客，在seanlook.github.com仓库下面建立了一个CNAME文件，内容：xgknight.com，然后去DNSPod绑定域名和IP（207.97.227.245）访问也就没事了。然而几天之后每次deploy博客的时候都会受到一封build warning邮件（见本文最后），后来参考下面的文章：
解决GitHub Pages Warning邮件提醒 一步步在GitHub上创建博客主页-最新版 — 自定义域名的新玩法 Faster, More Awesome GitHub Pages 和 GitHub Pages Legacy IP Deprecation 但显然第一篇有点拆东墙补西墙，只是换了个离自己最近的服务器，CDN根本就没用上，也是因为我dig seanlook.github.io &#43;nostats &#43;nocomments &#43;nocmd之后把IP改成了103.245.222.133，才有了第二封邮件的warning（见本文最后）。第二篇倒是跟官方（第三条）是同一个意思，但是博主放弃了原本的顶级域名而是用www子域名。 首先根据邮件提示，明确一下最终目的：
使用顶级域名xgknight.com来访问站点 子域名www.xgknight.com跳转到xgknight.com 充分Github Pages提供的cdn加速功能 两份邮件大概是同一个意思，说Github Pages正在进行重大的升级来提供更快的访问速度，所以我们指定的域名解析的IP在不就的将来将要废弃，需要指向一个合法的IP，第二封邮件说的更明确了，为了使用CDN加速功能，需要增加CNAME的子域名解析记录。
如果你正在使用顶级域名（example.com）而不是子域名（如www.example.com），并且你的DNS解析服务提供商不支持ALIAS记录，那么唯一的选择就是使用A记录，但这种配置没有办法利用CDN加速了（依然可以应对DoS攻击）。如果切换成子域名或使用支持ALIAS的DNS解析上，都可以利用CDN和应对DoS。
不料我现在的情形正是，使用顶级域名xgknight.com，DNSPod不支持ALIAS记录。虽然目前不使用CDN加速访问起来没感觉有多大问题，但对于我这种有轻微强迫症并追求完美的人来说，就是看不惯这个warnning。DNS解析服务不想换成付费的支持ALIAS的DNSimple，那么难道只能启用www子域名了吗？对于有些已经对你的网站做了链接的地方，随便修改域名可不是什么好事。于是我就尝试了下面的设置： 在DNSPod中去掉其它映射记录，添加CNAME记录的顶级域名映射到seanlook.github.com，github仓库下的CNAME文件也是顶级域名xgknight.com。经过这样设置后访问xgknight.com发现完全没有问题： 中国境内的ping值：
$ ping xgknight.com 正在 Ping github.map.fastly.net [103.245.222.133] 具有 32 字节的数据: 来自 103.245.222.133 的回复: 字节=32 时间=215ms TTL=42 来自 103.245.222.133 的回复: 字节=32 时间=210ms TTL=42 来自 103.245.222.133 的回复: 字节=32 时间=205ms TTL=42 来自 103.245.222.133 的回复: 字节=32 时间=221ms TTL=42 美国的一个IP的ping值：...</p>
  </div>
  <footer class="entry-footer"><span title='2014-11-08 01:21:25 +0000 UTC'>November 8, 2014</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to 完全解决Github Pages邮件两次warning（DNS解析问题）" href="http://xgknight.com/posts/2014/11/%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3github-pages%E9%82%AE%E4%BB%B6%E4%B8%A4%E6%AC%A1warningdns%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>docker常用管理命令（下）
    </h2>
  </header>
  <div class="entry-content">
    <p>本文承接docker专题(2)：docker常用管理命令（上）。
1. 开启/停止/重启container（start/stop/restart） 容器可以通过run新建一个来运行，也可以重新start已经停止的container，但start不能够再指定容器启动时运行的指令，因为docker只能有一个前台进程。 容器stop（或Ctrl&#43;D）时，会在保存当前容器的状态之后退出，下次start时保有上次关闭时更改。而且每次进入attach进去的界面是一样的，与第一次run启动或commit提交的时刻相同。
CONTAINER_ID=$(docker start &lt;containner_id&gt;) docker stop $CONTAINER_ID docker restart $CONTAINER_ID 关于这几个命令可以通过一个完整的实例使用：docker如何创建一个运行后台进程的容器并同时提供shell终端。
2. 连接到正在运行中的container（attach） 要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。 官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上 --sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。
# docker attach --sig-proxy=false $CONTAINER_ID 3. 查看image或container的底层信息（inspect） inspect的对象可以是image、运行中的container和停止的container。
查看容器的内部IP # docker inspect --format=&#39;{\{.NetworkSettings.IPAddress}}&#39; $CONTAINER_ID 172.17.42.35 （注：由于代码块解析的问题，上面NetworkSettings前面的 \ 去掉） 4. 删除一个或多个container、image（rm、rmi） 你可能在使用过程中会build或commit许多镜像，无用的镜像需要删除。但删除这些镜像是有一些条件的：
同一个IMAGE ID可能会有多个TAG（可能还在不同的仓库），首先你要根据这些 image names 来删除标签，当删除最后一个tag的时候就会自动删除镜像； 承上，如果要删除的多个IMAGE NAME在同一个REPOSITORY，可以通过docker rmi &lt;image_id&gt;来同时删除剩下的TAG；若在不同Repo则还是需要手动逐个删除TAG； 还存在由这个镜像启动的container时（即便已经停止），也无法删除镜像； TO-DO 如何查看镜像与容器的依存关系
** 删除容器 ** docker rm &lt;container_id/contaner_name&gt;
删除所有停止的容器 docker rm $(docker ps -a -q) ** 删除镜像 ** docker rmi &lt;image_id/image_name ....</p>
  </div>
  <footer class="entry-footer"><span title='2014-11-05 16:21:25 +0000 UTC'>November 5, 2014</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to docker常用管理命令（下）" href="http://xgknight.com/posts/2014/11/docker%E5%B8%B8%E7%94%A8%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E4%B8%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>docker如何创建一个运行后台进程的容器并同时提供shell终端
    </h2>
  </header>
  <div class="entry-content">
    <p>只看标题还不是很明显，本文实现docker的这样一种比较常用的功能：通过docker run启动一个容器后，容器中已经运行了一个后台进程（这里以监听80端口的nginx为例），同时进入一个shell终端可供操作，而不受限于只能在前台运行nginx与运行shell终端之间的一种。这个例子实现了，那么其他类似的运行多任务docker就可以以此类推。另外本文还提供了一种在docker容器内部安装软件（vim）的方法，对于定制自己需要的镜像大有帮助。 你可能需要先阅读docker专题(2)：docker常用管理命令（上）、docker专题(2)：docker常用管理命令（下）来理解更多。
1. 已经pull了官方的nginx 1.7.6的镜像（也可以从私服获取）## # docker images|grep nginx nginx 1.7.6 561ed4952ef0 10 days ago 100 MB 2. 根据官方指示启动这个容器 先做好自己要显示的页面 # echo &#34;&lt;h2 &gt;This is nginx official container running &lt;/h2&gt; &lt;br /&gt; static files:/tmp/doccker/index.html&#34; &gt; /tmp/docker/index.html 使用官方image启动一个容器，名字nginx_dist，把host的目录（包含刚才的html）映射到容器中nginx server的root，绑定80端口：
# docker run --name nginx_dist -v /tmp/docker:/usr/share/nginx/html:ro \ &gt; -p 80:80 -d nginx:1.7.6 1b10b08d7905517a26c72ce8b17b719aaea5e5eac0889263db8b017427e3c8f7 # docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1b10b08d7905 nginx:1 nginx -g &#39;daemon off 51 seconds ago Up 48 seconds 443/tcp, 0....</p>
  </div>
  <footer class="entry-footer"><span title='2014-11-03 20:21:25 +0000 UTC'>November 3, 2014</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to docker如何创建一个运行后台进程的容器并同时提供shell终端" href="http://xgknight.com/posts/2014/11/docker%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%BF%90%E8%A1%8C%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B9%B6%E5%90%8C%E6%97%B6%E6%8F%90%E4%BE%9Bshell%E7%BB%88%E7%AB%AF/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>记一次错误卸载软件包导致Linux系统崩溃的修复解决过程
    </h2>
  </header>
  <div class="entry-content">
    <p>首先问题产生的缘由很简单，是我一同事在安装oracle一套软件时，按照要求需要binutils软件包的32位版本，然而在Oracle Linux已经装有64位，按理说是可以安装i686的，我猜应该是32位的版本低于这个已有的64位所以导致冲突而安装失败，因此同事就用yum remove binutils，这个命令也奇葩，由于是root权限导致依赖于它的200多个软件包也被卸载，最终导致网络断开，系统崩溃，在vSphere虚拟机上重新启动发现再也起不来。下面看问题：
1. Kernel panic - not syncing: Attempted to kill init! 这个错误时在重新启动Oracle Linux一开始就出现，查阅的相关资料得知Kernel panic问题一般是由驱动模块终端处理终端问题导致的（不懂。。。），一开始我以为是驱动程序依赖于binutils导致被卸载，因此第一反应是想办法把缺失的软件装回去。实际上，是由于安全访问控制模块selinux的问题，参考类似问题。于是检查vi /etc/selinux/config时发现SELINUX=disables，拼写错误，应为disabled。 当再次启动没再出现该错误时，我高兴的认为原来这么简单就帮同事解决了，事实这根本还没到200多个软件包缺失而导致系统崩溃那一步。
2. 系统启动加载条完成后，一直hang住不动 这无疑要使用LiveCD修复系统了，参考Ultimate method to install package from linux rescue mode或Using Rescue Mode to Fix..Problems。因为知道出问题前做过什么操作，下面直接上解决问题的过程。
2.1 将系统DVD安装镜像加载到光驱 再次重启就自动进入安装界面，我们当然选择rescue mode： 一路按照提示确定（可以不配置network，这里就不贴图了，很简单），最终会提供给用户一个shell终端，对应的是从DVD光驱加载进来的系统，执行chroot /mnt/sysimage才会进入到原损坏的Linux系统，还好yum和rpm命令还可以使用，悲剧的是我并不知道yum remove命令卸载了哪些软件包。
2.2 安装缺失的软件包 这里得谢天谢地yum命令的安装卸载日志/var/log/yum.log，这个日志里清楚的记录了installed和erased的所有软件包，用rpm是不可能了，因为270多个包的依赖关系难以解决，只能通过yum方式，而由于rescue模式没有配置网络，因此只能使用本地镜像源。
在rescue系统下挂载光驱到待修复系统中的/media目录 bash-4.1# mount /dev/cdrom /mnt/sysimage/media chroot进入待修复系统 bash-4.1# chroot /mnt/sysimage 手动编辑一个仓库源（真实待修复的系统） sh-4.1# cd /etc/yum.repos.d/ &amp;&amp; vi Oracle-Media.repo [DVD-media] name=oracle-$releasever - Media baseurl=file:///media gpgcheck=0 enabled=1 建议只留Oracle-Media.repo文件，其他的.repo文件都mv成.bak，以防连接不了这些源而报错，虽然报错关系不大。 获取被依赖erased掉的软件列表
你可以将yum.log中多余的部分去掉，筛选出应该重新安装的packages： sh-4....</p>
  </div>
  <footer class="entry-footer"><span title='2014-11-03 01:21:25 +0000 UTC'>November 3, 2014</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to 记一次错误卸载软件包导致Linux系统崩溃的修复解决过程" href="http://xgknight.com/posts/2014/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%94%99%E8%AF%AF%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AF%BC%E8%87%B4linux%E7%B3%BB%E7%BB%9F%E5%B4%A9%E6%BA%83%E7%9A%84%E4%BF%AE%E5%A4%8D%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>docker常用管理命令（上）
    </h2>
  </header>
  <div class="entry-content">
    <p>本文只记录docker命令在大部分情境下的使用，如果想了解每一个选项的细节，请参考官方文档，这里只作为自己以后的备忘记录下来。
根据自己的理解，总的来说分为以下几种： 容器生命周期管理 — docker [run|start|stop|restart|kill|rm|pause|unpause] 容器操作运维 — docker [ps|inspect|top|attach|events|logs|wait|export|port] 容器rootfs命令 — docker [commit|cp|diff] 镜像仓库 — docker [login|pull|push|search] 本地镜像管理 — docker [images|rmi|tag|build|history|save|import] 其他命令 — docker [info|version]
看一个变迁图 1. 列出机器上的镜像（images） # docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu 14.10 2185fd50e2ca 13 days ago 236.9 MB … 其中我们可以根据REPOSITORY来判断这个镜像是来自哪个服务器，如果没有 / 则表示官方镜像，类似于username/repos_name表示Github的个人公共库，类似于regsistory.example.com:5000/repos_name则表示的是私服。 IMAGE ID列其实是缩写，要显示完整则带上--no-trunc选项
2. 在docker index中搜索image（search） Usage: docker search TERM # docker search seanlo NAME DESCRIPTION STARS OFFICIAL AUTOMATED seanloook/centos6 sean&#39;s docker repos 0 搜索的范围是官方镜像和所有个人公共镜像。NAME列的 / 后面是仓库的名字。...</p>
  </div>
  <footer class="entry-footer"><span title='2014-10-31 20:21:25 +0000 UTC'>October 31, 2014</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to docker常用管理命令（上）" href="http://xgknight.com/posts/2014/10/docker%E5%B8%B8%E7%94%A8%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E4%B8%8A/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>管理多tomcat服务shell脚本（CentOS）
    </h2>
  </header>
  <div class="entry-content">
    <p>该脚本改自csdn上的一个shell，忘记出处了，只记得它能够简单的通过service tomcat [stop|start|restart]来方便的管理Linux服务器上的tomcat，这可以满足大部分人的需求，然而并不适合我所管理的CentOS上的tomcat应用：通过端口区分的3台tomcat集群。如果每一次管理tomcat或查看日志，都cd /apps/test/tomcat0/log/然后切换到另外一个cd ../../或cd /apps/test/tomcat1/log/，麻烦至极。因此“懒人”创造了这个脚本tomcat：
#!/bin/bash # author: Sean Chow (seanlook7@gmail.com) # # # chkconfig: 345 80 15 # description: Multiple tomcats service management script. # Source function library. . /etc/rc.d/init.d/functions # 第几个tomcat tcNo=$1 tcName=tomcat$1 basedir=/apps/test/$tcName tclog=${basedir}/logs/catalina.$(date &#43;%Y-%m-%d).out RETVAL=0 start(){ checkrun if [ $RETVAL -eq 0 ]; then echo &#34;-- Starting tomcat...&#34; $basedir/bin/startup.sh touch /var/lock/subsys/${tcNo} checklog status else echo &#34;-- tomcat already running&#34; fi } # 停止某一台tomcat，如果是重启则带re参数，表示不查看日志，等待启动时再提示查看 stop(){ checkrun if [ $RETVAL -eq 1 ]; then echo &#34;-- Shutting down tomcat....</p>
  </div>
  <footer class="entry-footer"><span title='2014-10-29 18:21:25 +0000 UTC'>October 29, 2014</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to 管理多tomcat服务shell脚本（CentOS）" href="http://xgknight.com/posts/2014/10/%E7%AE%A1%E7%90%86%E5%A4%9Atomcat%E6%9C%8D%E5%8A%A1shell%E8%84%9A%E6%9C%ACcentos/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>apache&#43;3tomcat&#43;jk&#43;memcached集群环境搭建
    </h2>
  </header>
  <div class="entry-content">
    <p>注意本文不讨论原理，只讲述具体的搭建过程，而且步骤都经过了整理，否则过程可能会出现其他异常，请自行google。apache与tomcat整合的方式除了jk之外，使用apache自带的mod_ajp_proxy模块也可以很方便的完成。 先来看一下架构图： 属于正式环境中原session复制方案的改进。
1. 所需软件包 jrrt-3.1.2-1.6.0-linux-x64.bin（或jdk1.6.0_33） jvm httpd-2.2.26.tar.gz web服务器，处理静态资源 apache-tomcat-6.0.32.tar.gz 应用服务器，Servlet容器处理动态请求 tomcat-connectors-1.2.30-src.tar.gz apache与tomcat整合插件mod_jk.so tomcat-native.tar.gz APR加速tomcat，提高线程并发能力。使用tomcat自带版本。 memcached-session-manager 使用msm解决多tomcat集群时session同步问题所需jar包 asm-3.2.jar, couchbase-client-1.2.2.jar, kryo-1.04.jar, kryo-serializers-0.11.jar msm-kryo-serializer-1.6.5.jar memcached-session-manager-1.6.5.jar memcached-session-manager-tc6-1.6.5.jar minlog-1.2.jar, reflectasm-1.01.jar spymemcached-2.10.2.jar 2. 安装过程 2.1 JDK 下载将JRockit二进制安装文件，赋予可执行权限
# pwd /apps/test/java # chmod o&#43;x jrrt*.bin # ./jrrt-3.1.2-1.6.0-linux-x64.bin 可不必为整个linux环境设置JAVA_HOME=&#34;/apps/test/java/jrrt-3.1.2-1.6.0&#34;，在tomcat中指定即可。
2.2 编译安装apache 因为tomcat-native依赖于apr，所以这里先直接从 httpd-2.2.26/srclib 目录下安装apache自带的apr和apr-util。
[root@cachets httpd-2.2.26]# pwd /apps/test/soft_src/httpd-2.2.26 [root@test httpd-2.2.26]# cd srclib/apr [root@test apr]# ./configure --prefix=/usr/local/apr [root@test apr]# make &amp;&amp; make install [root@test apr]# cd ../apr-util/ [root@test apr-util]# ....</p>
  </div>
  <footer class="entry-footer"><span title='2014-10-29 10:21:25 +0000 UTC'>October 29, 2014</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to apache&#43;3tomcat&#43;jk&#43;memcached集群环境搭建" href="http://xgknight.com/posts/2014/10/apache-3tomcat-jk-memcached%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>误删vSphere虚拟机.vmdk文件的恢复
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 错误描述 在vSphere上，一次重启虚拟服务器时出现启动不了，提示找不到vmdk虚拟磁盘文件： 2. 原因分析 查看这台虚拟服务器的摘要信息，对比datastore上其他可用的虚拟机，发现损坏的服务器上确实缺少一个vmdk磁盘文件，但是可以看见一个50G的xxx-flat.vmdk文件；而正常的服务器只有xxx.vmdk，没有xxx-flat.vmdk，关机之后两个文件都存在，而且真实的磁盘容量从vmdk转移到了xxx-flat.vmdk。 虚拟主机在运行的时候，实际在使用的是xxx-flat.vmdk，然而xxx.vmdk是可以同时被删除的，才导致了问题。
这里需要说明，虚拟机的每个磁盘驱动器都包含了一对.vmdk文件。一个是文本文件，包含了关于虚拟硬盘的描述数据；另外一个是磁盘的实际内容。例如，一个名为examplevm的虚拟机连接有一个硬盘。这个磁盘由如下两个文件构成：一个小于 1KB 的examplevm.vmdk描述文件和一个10GB大小的examplevm- flat.vmdk平面（数据）文件，该文件包含虚拟机的实际数据，而这些数据又是以二进制的形式存放在物理磁盘上，examplevm.vmdk描述文件就是描述这种映射关系的。 另外：
A note for ESX-users: Do not use Datastorebrowser to identify vmdks or download them for editiing. The Datastorebrowser does not display vmdks correctly. It usually hides *-flat.vmdks and *-delta.vmdks.
TO-DO: 后续为 VMware ESXi 5 的磁盘专门记录一篇文章，说明“置备空间”以及vmfstools工具的使用。
3. 解决办法 (1) 用ssh登录vsphere主机，查找xxx-flat.vmdk文件所在的位置以及目录，并记录文件的大小
~ # find / -name &#34;新建虚拟机-flat.vmdk&#34; /vmfs/volumes/50a98441-ab02c8b7-e60a-001517712dce/新建虚拟机/新建虚拟机-flat.vmdk ~ # ls -l /vmfs/volumes/50a98441-ab02c8b7-e60a-001517712dce/新建虚拟机/新建虚拟机-flat.vmdk -rw------- 1 root root 53687091200 Apr 16 09:13 /vmfs/volumes/50a98441-ab02c8b7-e60a-001517712dce/新建虚拟机/新建虚拟机-flat....</p>
  </div>
  <footer class="entry-footer"><span title='2014-10-28 15:21:25 +0000 UTC'>October 28, 2014</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to 误删vSphere虚拟机.vmdk文件的恢复" href="http://xgknight.com/posts/2014/10/%E8%AF%AF%E5%88%A0vsphere%E8%99%9A%E6%8B%9F%E6%9C%BA.vmdk%E6%96%87%E4%BB%B6%E7%9A%84%E6%81%A2%E5%A4%8D/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>在 CentOS 6.x上安装 docker.io成功
    </h2>
  </header>
  <div class="entry-content">
    <p>docker是什么就不多说了，见docker基础原理介绍。 docker容器最早受到RHEL完善的支持是从最近的CentOS 7.0开始的，官方说明是只能运行于64位架构平台，内核版本为2.6.32-431及以上（即&gt;=CentOS 6.5，运行docker时实际提示3.8.0及以上），升级内核请参考CentOS 6.x 内核升级（2.6.32 -&gt; 3.10.58）过程记录 需要注意的是CentOS 6.5与7.0的安装是有一点点不同的，CentOS-6上docker的安装包叫docker-io，并且来源于Fedora epel库，这个仓库维护了大量的没有包含在发行版中的软件，所以先要安装EPEL，而CentOS-7的docker直接包含在官方镜像源的Extras仓库（CentOS-Base.repo下的[extras]节enable=1启用）。前提是都需要联网，具体安装过程如下。 ###1. 禁用selinux###
# getenforce enforcing # setenforce 0 permissive # vi /etc/selinux/config SELINUX=disabled ... ###2. 安装 Fedora EPEL### epel-release-6-8.noarch.rpm包在发行版的介质里面已经自带了，可以从rpm安装。
# yum install epel-release-6-8.noarch.rpm //或 yum -y install http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm 如果出现GPG key retrieval failed: [Errno 14] Could not open/read file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6问题，请在线安装epel，下载RPM-GPG-KEY-EPEL-6文件。 这一步执行之后，会在/etc/yum.repos.d/下生成epel.repo、epel-testing.repo两个文件，用于从Fedora官网下载rpm包。 ###3. 检查内核版本###
# uname -r 2.6.32-431.el6.x86_64 # cat /etc/redhat-release CentOS release 6.5 (Final) 看到这个最低的内核版本，事实运行起来是没太大问题的，你也可以升级到3.10.x版本。 另外你也可以运行脚本check-config.sh，来检查内核模块符不符合（下面有些missing的，我的docker还是可以正常启动）：
[root@sean ~]# ./check-config warning: /proc/config.gz does not exist, searching other paths for kernel config....</p>
  </div>
  <footer class="entry-footer"><span title='2014-10-26 19:45:25 +0000 UTC'>October 26, 2014</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to 在 CentOS 6.x上安装 docker.io成功" href="http://xgknight.com/posts/2014/10/%E5%9C%A8-centos-6.x%E4%B8%8A%E5%AE%89%E8%A3%85-docker.io%E6%88%90%E5%8A%9F/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://xgknight.com/posts/page/10/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://xgknight.com/posts/page/12/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="http://xgknight.com/">Sean Note</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
