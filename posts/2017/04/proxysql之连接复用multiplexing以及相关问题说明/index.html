<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>ProxySQL之连接复用（multiplexing）以及相关问题说明 | Sean Note</title>
<meta name="keywords" content="mysql, 中间件, proxysql">
<meta name="description" content="ProxySQL在连接池(persistent connection poll)的基础上，还有一个连接复用的概念 multiplexing connection，官方的wiki里没有很明确的说明，但在作者的一些 blog post 和 issue 里能找到解答： https://github.com/sysown/proxysql/issues/939#issuecomment-287489317
由于SQL可以路由，一个客户端连接上来，可能会到多个 hostgroup 发起连接。复用的意思是，一个后端DB的连接，可以“同时”被多个客户端使用。
传统的连接池，会在客户端断开连接（会话）后，把连接放回到池里。在ProxySQL中，由于连接复用，连接会在sql语句执行结束后，便将连接放回到池里（客户端会话可能并没有断开），这样便可大大提高后端连接的使用效率，而避免前段请求过大导致后端连接数疯长。
但这样做有时候并不安全，比如应用端连接时指定了 set NAMES xxx，然后执行查询，那么由于multiplexing可能导致两个语句发到不同的DB上执行，继而没有按照预期的字符集执行。proxysql考虑到了这种情况：
连接会话里创建了临时表，CREATE TEMPORARY table xxxx... select @开头的变量，如select @@hostname 手动开启了事务，start transaction, commit, rollback等等 连接设置了自己的用户变量，比如set names xxx, set autocommit x, set sql_mode=xxx, set v_uservar=xx等等 第1,2,3点会根据路由规则，会自动禁用multiplex，发到对应hostgroup后，连接未断开之前不会复用到其它客户端。具体是发到主库还是从库，与匹配的规则有关。 issue #941 和 #917 都有提到临时表丢失的问题，可以用不同的rule来避免
下面对上面几点一一说明。
1. 临时表与用户变量（验证 1, 2） 以下注意连接的会话窗口及执行顺序，admin打头的是在proxysql管理接口上执行。
-- [session 1] mysql client proxysql (ecdba@10.0.100.36:6033) [(none)]&gt; select 1; &#43;---&#43; | 1 | &#43;---&#43; | 1 | &#43;---&#43; -- [session 2] proxysql admin cli select * from stats_mysql_processlist; Empty set (0.">
<meta name="author" content="admin">
<link rel="canonical" href="http://xgknight.com/posts/2017/04/proxysql%E4%B9%8B%E8%BF%9E%E6%8E%A5%E5%A4%8D%E7%94%A8multiplexing%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css" integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://xgknight.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://xgknight.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://xgknight.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://xgknight.com/apple-touch-icon.png">
<link rel="mask-icon" href="http://xgknight.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="ProxySQL之连接复用（multiplexing）以及相关问题说明" />
<meta property="og:description" content="ProxySQL在连接池(persistent connection poll)的基础上，还有一个连接复用的概念 multiplexing connection，官方的wiki里没有很明确的说明，但在作者的一些 blog post 和 issue 里能找到解答： https://github.com/sysown/proxysql/issues/939#issuecomment-287489317
由于SQL可以路由，一个客户端连接上来，可能会到多个 hostgroup 发起连接。复用的意思是，一个后端DB的连接，可以“同时”被多个客户端使用。
传统的连接池，会在客户端断开连接（会话）后，把连接放回到池里。在ProxySQL中，由于连接复用，连接会在sql语句执行结束后，便将连接放回到池里（客户端会话可能并没有断开），这样便可大大提高后端连接的使用效率，而避免前段请求过大导致后端连接数疯长。
但这样做有时候并不安全，比如应用端连接时指定了 set NAMES xxx，然后执行查询，那么由于multiplexing可能导致两个语句发到不同的DB上执行，继而没有按照预期的字符集执行。proxysql考虑到了这种情况：
连接会话里创建了临时表，CREATE TEMPORARY table xxxx... select @开头的变量，如select @@hostname 手动开启了事务，start transaction, commit, rollback等等 连接设置了自己的用户变量，比如set names xxx, set autocommit x, set sql_mode=xxx, set v_uservar=xx等等 第1,2,3点会根据路由规则，会自动禁用multiplex，发到对应hostgroup后，连接未断开之前不会复用到其它客户端。具体是发到主库还是从库，与匹配的规则有关。 issue #941 和 #917 都有提到临时表丢失的问题，可以用不同的rule来避免
下面对上面几点一一说明。
1. 临时表与用户变量（验证 1, 2） 以下注意连接的会话窗口及执行顺序，admin打头的是在proxysql管理接口上执行。
-- [session 1] mysql client proxysql (ecdba@10.0.100.36:6033) [(none)]&gt; select 1; &#43;---&#43; | 1 | &#43;---&#43; | 1 | &#43;---&#43; -- [session 2] proxysql admin cli select * from stats_mysql_processlist; Empty set (0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://xgknight.com/posts/2017/04/proxysql%E4%B9%8B%E8%BF%9E%E6%8E%A5%E5%A4%8D%E7%94%A8multiplexing%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-04-17T21:32:49+00:00" />
<meta property="article:modified_time" content="2017-04-17T21:32:49+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ProxySQL之连接复用（multiplexing）以及相关问题说明"/>
<meta name="twitter:description" content="ProxySQL在连接池(persistent connection poll)的基础上，还有一个连接复用的概念 multiplexing connection，官方的wiki里没有很明确的说明，但在作者的一些 blog post 和 issue 里能找到解答： https://github.com/sysown/proxysql/issues/939#issuecomment-287489317
由于SQL可以路由，一个客户端连接上来，可能会到多个 hostgroup 发起连接。复用的意思是，一个后端DB的连接，可以“同时”被多个客户端使用。
传统的连接池，会在客户端断开连接（会话）后，把连接放回到池里。在ProxySQL中，由于连接复用，连接会在sql语句执行结束后，便将连接放回到池里（客户端会话可能并没有断开），这样便可大大提高后端连接的使用效率，而避免前段请求过大导致后端连接数疯长。
但这样做有时候并不安全，比如应用端连接时指定了 set NAMES xxx，然后执行查询，那么由于multiplexing可能导致两个语句发到不同的DB上执行，继而没有按照预期的字符集执行。proxysql考虑到了这种情况：
连接会话里创建了临时表，CREATE TEMPORARY table xxxx... select @开头的变量，如select @@hostname 手动开启了事务，start transaction, commit, rollback等等 连接设置了自己的用户变量，比如set names xxx, set autocommit x, set sql_mode=xxx, set v_uservar=xx等等 第1,2,3点会根据路由规则，会自动禁用multiplex，发到对应hostgroup后，连接未断开之前不会复用到其它客户端。具体是发到主库还是从库，与匹配的规则有关。 issue #941 和 #917 都有提到临时表丢失的问题，可以用不同的rule来避免
下面对上面几点一一说明。
1. 临时表与用户变量（验证 1, 2） 以下注意连接的会话窗口及执行顺序，admin打头的是在proxysql管理接口上执行。
-- [session 1] mysql client proxysql (ecdba@10.0.100.36:6033) [(none)]&gt; select 1; &#43;---&#43; | 1 | &#43;---&#43; | 1 | &#43;---&#43; -- [session 2] proxysql admin cli select * from stats_mysql_processlist; Empty set (0."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://xgknight.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "ProxySQL之连接复用（multiplexing）以及相关问题说明",
      "item": "http://xgknight.com/posts/2017/04/proxysql%E4%B9%8B%E8%BF%9E%E6%8E%A5%E5%A4%8D%E7%94%A8multiplexing%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ProxySQL之连接复用（multiplexing）以及相关问题说明",
  "name": "ProxySQL之连接复用（multiplexing）以及相关问题说明",
  "description": "ProxySQL在连接池(persistent connection poll)的基础上，还有一个连接复用的概念 multiplexing connection，官方的wiki里没有很明确的说明，但在作者的一些 blog post 和 issue 里能找到解答： https://github.com/sysown/proxysql/issues/939#issuecomment-287489317\n由于SQL可以路由，一个客户端连接上来，可能会到多个 hostgroup 发起连接。复用的意思是，一个后端DB的连接，可以“同时”被多个客户端使用。\n传统的连接池，会在客户端断开连接（会话）后，把连接放回到池里。在ProxySQL中，由于连接复用，连接会在sql语句执行结束后，便将连接放回到池里（客户端会话可能并没有断开），这样便可大大提高后端连接的使用效率，而避免前段请求过大导致后端连接数疯长。\n但这样做有时候并不安全，比如应用端连接时指定了 set NAMES xxx，然后执行查询，那么由于multiplexing可能导致两个语句发到不同的DB上执行，继而没有按照预期的字符集执行。proxysql考虑到了这种情况：\n连接会话里创建了临时表，CREATE TEMPORARY table xxxx... select @开头的变量，如select @@hostname 手动开启了事务，start transaction, commit, rollback等等 连接设置了自己的用户变量，比如set names xxx, set autocommit x, set sql_mode=xxx, set v_uservar=xx等等 第1,2,3点会根据路由规则，会自动禁用multiplex，发到对应hostgroup后，连接未断开之前不会复用到其它客户端。具体是发到主库还是从库，与匹配的规则有关。 issue #941 和 #917 都有提到临时表丢失的问题，可以用不同的rule来避免\n下面对上面几点一一说明。\n1. 临时表与用户变量（验证 1, 2） 以下注意连接的会话窗口及执行顺序，admin打头的是在proxysql管理接口上执行。\n-- [session 1] mysql client proxysql (ecdba@10.0.100.36:6033) [(none)]\u0026gt; select 1; +---+ | 1 | +---+ | 1 | +---+ -- [session 2] proxysql admin cli select * from stats_mysql_processlist; Empty set (0.",
  "keywords": [
    "mysql", "中间件", "proxysql"
  ],
  "articleBody": "ProxySQL在连接池(persistent connection poll)的基础上，还有一个连接复用的概念 multiplexing connection，官方的wiki里没有很明确的说明，但在作者的一些 blog post 和 issue 里能找到解答： https://github.com/sysown/proxysql/issues/939#issuecomment-287489317\n由于SQL可以路由，一个客户端连接上来，可能会到多个 hostgroup 发起连接。复用的意思是，一个后端DB的连接，可以“同时”被多个客户端使用。\n传统的连接池，会在客户端断开连接（会话）后，把连接放回到池里。在ProxySQL中，由于连接复用，连接会在sql语句执行结束后，便将连接放回到池里（客户端会话可能并没有断开），这样便可大大提高后端连接的使用效率，而避免前段请求过大导致后端连接数疯长。\n但这样做有时候并不安全，比如应用端连接时指定了 set NAMES xxx，然后执行查询，那么由于multiplexing可能导致两个语句发到不同的DB上执行，继而没有按照预期的字符集执行。proxysql考虑到了这种情况：\n连接会话里创建了临时表，CREATE TEMPORARY table xxxx... select @开头的变量，如select @@hostname 手动开启了事务，start transaction, commit, rollback等等 连接设置了自己的用户变量，比如set names xxx, set autocommit x, set sql_mode=xxx, set v_uservar=xx等等 第1,2,3点会根据路由规则，会自动禁用multiplex，发到对应hostgroup后，连接未断开之前不会复用到其它客户端。具体是发到主库还是从库，与匹配的规则有关。 issue #941 和 #917 都有提到临时表丢失的问题，可以用不同的rule来避免\n下面对上面几点一一说明。\n1. 临时表与用户变量（验证 1, 2） 以下注意连接的会话窗口及执行顺序，admin打头的是在proxysql管理接口上执行。\n-- [session 1] mysql client proxysql (ecdba@10.0.100.36:6033) [(none)]\u003e select 1; +---+ | 1 | +---+ | 1 | +---+ -- [session 2] proxysql admin cli select * from stats_mysql_processlist; Empty set (0.00 sec) 普通查询，session 1 没断开，但后端连接已放回连接池，所以看不到processlist。下面试验临时表： -- [session 1] mysql client proxysql (ecdba@10.0.100.36:6033) [(none)]\u003e CREATE TEMPORARY TABLE db0.tbl_tmp(id int); Query OK, 0 rows affected (0.18 sec) -- [session 2] proxysql admin cli (admin@127.0.0.1:6032) [(none)]\u003e select * from stats_mysql_processlist; +----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+ | ThreadID | SessionID | user | db | cli_host | cli_port | hostgroup | l_srv_host | l_srv_port | srv_host | srv_port | command | time_ms | info | +----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+ | 0 | 60 | ecdba | information_schema | 10.0.100.34 | 27058 | 100 | 10.0.100.36 | 41245 | 10.0.100.100 | 3307 | Sleep | 4506 | | +----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+ 1 row in set (0.00 sec) 看到后端的连接没有释放回连接池，但是在 session 1 里select却看不到刚才创建的临时表： -- [session 1] (ecdba@10.0.100.36:6033) [(none)]\u003e select * from db0.tbl_tmp; ERROR 1146 (42S02): Table 'db0.tbl_tmp' doesn't exist -- [session 2] (admin@127.0.0.1:6032) [(none)]\u003e select * from stats_mysql_processlist; +----------+-----------+-------+--------------------+-------------+----------+-----------+------------+------------+----------+----------+---------+---------+------+ | ThreadID | SessionID | user | db | cli_host | cli_port | hostgroup | l_srv_host | l_srv_port | srv_host | srv_port | command | time_ms | info | +----------+-----------+-------+--------------------+-------------+----------+-----------+------------+------------+----------+----------+---------+---------+------+ | 0 | 60 | ecdba | information_schema | 10.0.100.34 | 27058 | 1000 | | | | | Sleep | 2002 | | +----------+-----------+-------+--------------------+-------------+----------+-----------+------------+------------+----------+----------+---------+---------+------+ 1 row in set (0.00 sec) select之后，发现上面的srv_host为空。下面往临时表里插数据，正常，且连接被 session 1 客户端持有： -- [session 1] (ecdba@10.0.100.36:6033) [(none)]\u003e insert into db0.tbl_tmp values(1); Query OK, 1 row affected (0.01 sec) -- [session 2] (admin@127.0.0.1:6032) [(none)]\u003e select * from stats_mysql_processlist; +----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+ | ThreadID | SessionID | user | db | cli_host | cli_port | hostgroup | l_srv_host | l_srv_port | srv_host | srv_port | command | time_ms | info | +----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+ | 0 | 60 | ecdba | information_schema | 10.0.100.34 | 27058 | 100 | 10.0.100.36 | 41245 | 10.0.100.100 | 3307 | Sleep | 2996 | | +----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+ 1 row in set (0.00 sec) -- [session 1] (ecdba@10.0.100.36:6033) [(none)]\u003e select 1; +---+ | 1 | +---+ | 1 | +---+ -- [session 2] (admin@127.0.0.1:6032) [(none)]\u003e select * from stats_mysql_processlist; +----------+-----------+-------+--------------------+-------------+----------+-----------+------------+------------+----------+----------+---------+---------+------+ | ThreadID | SessionID | user | db | cli_host | cli_port | hostgroup | l_srv_host | l_srv_port | srv_host | srv_port | command | time_ms | info | +----------+-----------+-------+--------------------+-------------+----------+-----------+------------+------------+----------+----------+---------+---------+------+ | 0 | 60 | ecdba | information_schema | 10.0.100.34 | 27058 | 1000 | | | | | Sleep | 2303 | | +----------+-----------+-------+--------------------+-------------+----------+-----------+------------+------------+----------+----------+---------+---------+------+ 通过上面的过程可以看见，proxysql在遇到与会话本身相关的变量或操作时，自动禁用了multiplexing，并且针对整个会话有效，直到断开连接。另外，禁用了multiplexing，但路由规则依然生效，这就导致了select临时表时路由到了其它实例， Table xxx doesn’t exist。\n2. 显式start transaction (验证3) 第1,2点根据开发的习惯，都可以避免使用，但显式事务有时却不得不用，也做一个测试。\n为了效果明显，我将一个不相干的实例，分配同一个hostgroup_id，权重1:1 -- [session 1] (ecdba@10.0.100.36:6033) [(none)]\u003e select * from db0.tbl_0; +-----+----------+--------+ | fid | username | corpid | +-----+----------+--------+ | 1 | db0 aa | 0 | | 2 | db0 aa | 16 | | 3 | db0 aa | 32 | +-----+----------+--------+ (ecdba@10.0.100.36:6033) [(none)]\u003e select * from db0.tbl_0; ERROR 1146 (42S02): Table 'db0.tbl_0' doesn't exist (ecdba@10.0.100.36:6033) [(none)]\u003e begin; -- 开启一个事务 (ecdba@10.0.100.36:6033) [(none)]\u003e select * from db0.tbl_0; +-----+----------+--------+ | fid | username | corpid | +-----+----------+--------+ | 1 | db0 aa | 0 | | 2 | db0 aa | 16 | | 3 | db0 aa | 32 | +-----+----------+--------+ (ecdba@10.0.100.36:6033) [(none)]\u003e select * from db0.tbl_0; ERROR 1146 (42S02): Table 'db0.tbl_0' doesn't exist 这就尴尬了，明显是在同一个事务里面，后端依然请求了多个backend。设置 transaction_persistent ： -- [session 2] (admin@127.0.0.1:6032) [(none)]\u003e update mysql_users set transaction_persistent=1 where username='ecdba'; (admin@127.0.0.1:6032) [(none)]\u003e load mysql users to run; -- [session 1] (ecdba@10.0.100.36:6033) [(none)]\u003e begin; Query OK, 0 rows affected (0.00 sec) (ecdba@10.0.100.36:6033) [(none)]\u003e select * from db0.tbl_0; +-----+----------+--------+ | fid | username | corpid | +-----+----------+--------+ | 1 | db0 aa | 0 | | 2 | db0 aa | 16 | | 3 | db0 aa | 32 | +-----+----------+--------+ 反复执行多次还是上面的结果。 看到到后端连接的情况： -- [session 2] (admin@127.0.0.1:6032) [(none)]\u003e select * from stats_mysql_processlist; +----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+ | ThreadID | SessionID | user | db | cli_host | cli_port | hostgroup | l_srv_host | l_srv_port | srv_host | srv_port | command | time_ms | info | +----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+ | 3 | 73 | ecdba | information_schema | 10.0.100.34 | 45030 | 100 | 10.0.100.36 | 6057 | 10.0.100.100 | 3307 | Sleep | 43046 | | +----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+ 1 row in set (0.00 sec) 看到用户的 transaction_persistent 属性可以保证在同一个事务内的所有sql，都发向后端同一个db实例。如果它为0，同时一个hostgroup有多个可用slave，可能由于不同从库的延迟不一样，而查到不一致的数据。\ntransaction_persistent=1 时还注意一下隐藏的一点点细节，begin 开启事务后，事务内所有语句包括select，都路由到了主库，这是因为 begin 匹配规则选择的是主库，后续的查询都跟着走;而 transaction_persistent=0 时 bgein 由于路由规则作用，也发到了主库，但后续的select,update等是不受它约束，继续根据路由规则走。在 非 master-master 模式下，事务还是安全的。\n3.1 autocommit 会话变量 (验证4) 第 4 点略微有些复杂，开始之前先引用一段作者针对 issue #653 的回复：（不完全翻译）\nProxySQL doesn’t track user variable\nProxySQL不会记录 用户变量，当proxysql识别到 set @variable1 = 67 语句时，会自动禁用连接复用(disable multiplexing)，并根据路由规则选择后端节点（通常是写节点），执行完成后，连接不会放回连接池，直到disconnect。\nProxySQL tracks some session variables\nProxySQL会记录 会话变量，“记录” 的意思是，proxysql接收到这些会话变量后，不会马上从后端连接池去拿连接然后 set xxx （因为还没有足够的信息知道拿哪个用户哪个db的连接），而是在当前连接保存起来，等待下一个查询命令，然后一起发送到到后端。use dbname就是这样处理的。 当前，记录的只有 autocommit 和字符集变量、timezone。比如执行sql前发送一个 set autocommit=1，proxysql会马上返回一个 OK，代表它知道应用端设置了自动提交，等真正的dml请求过来时，它将与后端拿到的连接比较autocommit是否匹配，不匹配则先set再执行dml。\n当然现实还受到proxysql全局变量 mysql-enforce_autocommit_on_reads 的影响，即是否开启对读操作强制 autocommit。这个变量所解决的问题是，在同一个事务里既有 write 又有 read 且配置了读写分离的情况下，会导致在 读库 和 写库 各自开一个事务 (从库会set autocommit=0)，这就不合理了，所以把它设为 true 可以保证事务始终是一个。默认 false。 但是如上节所说，如果开启了 transaction_persistent=1，这个问题就不存在了。\n-- [session 1] (ecdba@10.0.100.36:6033) [(none)]\u003e set @variable1 = 67; -- [session 2] (admin@127.0.0.1:6032) [(none)]\u003e show processlist; +-----------+-------+--------------------+-----------+---------+---------+------+ | SessionID | user | db | hostgroup | command | time_ms | info | +-----------+-------+--------------------+-----------+---------+---------+------+ | 79 | ecdba | information_schema | 100 | Sleep | 8008 | | +-----------+-------+--------------------+-----------+---------+---------+------+ 1 row in set (0.00 sec) 与后端的连接已建立。但如果没有路由规则匹配到，proxysql会选择该用户 default_hostgroup，一般是0，由于没有 HG 0 记录，这个set variables会失败： -- [session 1] (ecdba@10.0.100.36:6033) [(none)]\u003e set @variable1 = 67; ERROR 9001 (HY000): Max connect timeout reached while reaching hostgroup 0 after 11462ms 同样情况下，set autocommit 和 set names 就很快返回，并且看不到后端有连接： (ecdba@10.0.100.36:6033) [(none)]\u003e set session transaction isolation level read committed; Query OK, 0 rows affected (0.00 sec) (ecdba@10.0.100.36:6033) [(none)]\u003e set autocommit=0; Query OK, 0 rows affected (0.00 sec) -- [session 2] (admin@127.0.0.1:6032) [(none)]\u003e show processlist; Empty set (0.00 sec) -- [session 1] begin开启一个事务，验证 transaction_persistent： (ecdba@10.0.100.36:6033) [(none)]\u003e UPDATE db0.tbl_0 set username='db0 autocommit' where fid=3; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 (ecdba@10.0.100.36:6033) [(none)]\u003e select * from db0.tbl_0; +-----+----------------+--------+ | fid | username | corpid | +-----+----------------+--------+ | 1 | db0 aa | 0 | | 2 | db0 aa | 16 | | 3 | db0 autocommit | 32 | +-----+----------------+--------+ 3 rows in set (0.00 sec) (ecdba@10.0.100.36:6033) [(none)]\u003e commit; Query OK, 0 rows affected (0.00 sec) 查看后端DB（主库）的 general_log：（都发到了主库） 9651978 Connect\tecdba@10.0.100.36 on information_schema 9651978 Query\tSET autocommit=0 9651978 Query\tUPDATE db0.tbl_0 set username='db0 autocommit' where fid=3 9651978 Query\tselect * from db0.tbl_0 9651978 Query\tcommit 这也告诉我们，尽量不要在 proxy admin cli 里面执行 show slave status， set global xxx 这样的管理命令，你较难预知到后端在哪里执行的。\n3.2 字符集prepared会话变量 (验证4) 对字符集 set NAMES xxx, set character_set_client=xxx，处理方法与上面 set autocommit 是一样的，但是遇到使用 prepared statement 时需要特别提一下。\n首先ProxySQL所支持的字符集，在表 mysql_collations 可以看到，它是直接从本地安装的mysql client lib获取的，proxysql默认使用的是utf8，指的是在连接的时候默认认为客户端的字符集是utf8。\n根据 issue #780：https://github.com/sysown/proxysql/issues/780 的讨论，某些框架比如 Laravel 在通过PDO连接MySQL时，执行 prepared statement时会连同 set NAMES xx 一起发送，导致没有生效。经测试，该问题在 v1.3.5 中已不存在：\n-- [session 1] mysql -uecweb -pweber -h10.0.100.34 -P6033 --default-character-set=latin1 (ecweb@10.0.100.34:6033) [(none)]\u003e select * from d_ec_crm.tttt; +-----+-------+ | fid | fname | +-----+-------+ | 1 | xx??? | +-----+-------+ latin1连接看utf8的数据，所以乱码。下面模拟 prepared statement 设置字符集： (ecweb@10.0.100.34:6033) [(none)]\u003e PREPARE stmt FROM 'SET NAMES utf8'; Query OK, 0 rows affected (0.00 sec) Statement prepared -- [session 2] (admin@127.0.0.1:6032) [(none)]\u003e select * from stats_mysql_processlist; +----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+---------------+----------+---------+---------+------+ | ThreadID | SessionID | user | db | cli_host | cli_port | hostgroup | l_srv_host | l_srv_port | srv_host | srv_port | command | time_ms | info | +----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+---------------+----------+---------+---------+------+ | 1 | 50 | ecweb | information_schema | 10.0.100.34 | 46389 | 110 | 10.0.100.34 | 31946 | 192.168.1.229 | 3307 | Sleep | 35649 | | +----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+---------------+----------+---------+---------+------+ 直接执行还是乱码，也要在prepared ： (ecweb@10.0.100.34:6033) [(none)]\u003e select * from d_ec_crm.tttt; +-----+-------+ | fid | fname | +-----+-------+ | 1 | xx??? | +-----+-------+ (ecweb@10.0.100.34:6033) [(none)]\u003e PREPARE stmt FROM 'select * from d_ec_crm.tttt'; Query OK, 0 rows affected (0.00 sec) Statement prepared (ecweb@10.0.100.34:6033) [(none)]\u003e EXECUTE stmt; +-----+-------------+ | fid | fname | +-----+-------------+ | 1 | xx嘻嘻嘻 | +-----+-------------+ 注意到 PREPARE stmt FROM 'SET NAMES utf8' 发送之后，马上与后端建立了连接，而不像上节set names xx止步于proxysql。所以是自动禁用了 multiplexing。\n3.3 set sql_mode 作者明确表示 sql_mode 在 1.3.x 版本里不会track，也就是它完全按照路由规则走，不会像临时表或用户变量那样 disable multiplexing automaticly，也不像上面的会话变量那样 “记录” 然后一并发送。\n如果sql_mode确实对应用使用造成困扰，1.4版本里会修复，在此前估计只好将连接复用的特性全局禁用：\nSET mysql-multiplexing='false'; LOAD MYSQL VARIABLES TO RUNTIME; SAVE MYSQL VARIABLES TO DISK; 参考 issue #916。禁用 multiplexing 后，就像一般的中间件连接池一样，维持或者释放连接。\n最后，关于 multiplexing 向作者提了一个特性 594#issuecomment-294703577 ：前端连接执行完一个查询，后端不马上把它返回连接池（复用），而是等待几秒，如果这个连接后续又有sql进来，就不需要重新从池里获取连接，还有检查一堆变量。renecannao 的回复非常及时，也确认 v1.4 会加上这个功能。\nupdated at 2017-07-27: 关于连接复用与连接池的差别，在后一次与作者的沟通中，更加明确了，见 #issue 1107: 问题始于发现环境中的connection pool没有起作用（禁用了multiplexing），因为一开始只是认为禁用了multiplexing，connection pool不会受影响。但实际不是的，在1.3.x版本里，禁用multiplexing，就相当于连接复用和连接池都没有了，前端应用在释放连接后，proxysql也把后端的连接释放了；在1.4.x版本里表现不同，禁用multiplexing后，前端连接释放，proxysql对后端的连接继续保持，并对连接重置以便重复利用。\n所以如果测试上没啥问题，建议开启连接复用，或者升级到 1.4.x 版本。\n原文连接地址：http://xgknight.com/2017/04/17/mysql-proxysql-multiplexing/\n",
  "wordCount" : "1326",
  "inLanguage": "en",
  "datePublished": "2017-04-17T21:32:49Z",
  "dateModified": "2017-04-17T21:32:49Z",
  "author":{
    "@type": "Person",
    "name": "admin"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://xgknight.com/posts/2017/04/proxysql%E4%B9%8B%E8%BF%9E%E6%8E%A5%E5%A4%8D%E7%94%A8multiplexing%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sean Note",
    "logo": {
      "@type": "ImageObject",
      "url": "http://xgknight.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://xgknight.com/" accesskey="h" title="Sean Note (Alt + H)">Sean Note</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://xgknight.com/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://xgknight.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      ProxySQL之连接复用（multiplexing）以及相关问题说明
    </h1>
    <div class="post-meta"><span title='2017-04-17 21:32:49 +0000 UTC'>April 17, 2017</span>&nbsp;·&nbsp;admin

</div>
  </header> 
  <div class="post-content"><p>ProxySQL在连接池(<em>persistent connection poll</em>)的基础上，还有一个连接复用的概念 <em>multiplexing connection</em>，官方的wiki里没有很明确的说明，但在作者的一些 blog post 和 issue 里能找到解答： <a href="https://github.com/sysown/proxysql/issues/939#issuecomment-287489317">https://github.com/sysown/proxysql/issues/939#issuecomment-287489317</a></p>
<p>由于SQL可以路由，一个客户端连接上来，可能会到多个 hostgroup 发起连接。复用的意思是，一个后端DB的连接，可以“同时”被多个客户端使用。</p>
<p>传统的连接池，会在客户端<strong>断开连接</strong>（会话）后，把连接放回到池里。在ProxySQL中，由于连接复用，连接会在<strong>sql语句</strong>执行结束后，便将连接放回到池里（客户端会话可能并没有断开），这样便可大大提高后端连接的使用效率，而避免前段请求过大导致后端连接数疯长。</p>
<p>但这样做有时候并不安全，比如应用端连接时指定了 <code>set NAMES xxx</code>，然后执行查询，那么由于multiplexing可能导致两个语句发到不同的DB上执行，继而没有按照预期的字符集执行。proxysql考虑到了这种情况：</p>
<ol>
<li>连接会话里创建了临时表，<code>CREATE TEMPORARY table xxxx...</code></li>
<li>select @开头的变量，如<code>select @@hostname</code></li>
<li>手动开启了事务，<code>start transaction</code>, <code>commit</code>, <code>rollback</code>等等</li>
<li>连接设置了自己的用户变量，比如<code>set names xxx</code>, <code>set autocommit x</code>, <code>set sql_mode=xxx</code>, <code>set v_uservar=xx</code>等等</li>
</ol>
<p>第1,2,3点会根据路由规则，会自动禁用multiplex，发到对应hostgroup后，连接未断开之前不会复用到其它客户端。具体是发到主库还是从库，与匹配的规则有关。
issue <a href="https://github.com/sysown/proxysql/issues/941">#941</a> 和 <a href="https://github.com/sysown/proxysql/issues/917">#917</a> 都有提到临时表丢失的问题，可以用不同的rule来避免</p>
<p>下面对上面几点一一说明。</p>
<h2 id="1-临时表与用户变量验证-1-2">1. 临时表与用户变量（验证 1, 2）<a hidden class="anchor" aria-hidden="true" href="#1-临时表与用户变量验证-1-2">#</a></h2>
<p>以下注意连接的会话窗口及执行顺序，admin打头的是在proxysql管理接口上执行。</p>
<pre tabindex="0"><code>-- [session 1] mysql client proxysql
(ecdba@10.0.100.36:6033) [(none)]&gt; select 1;
+---+
| 1 |
+---+
| 1 |
+---+

-- [session 2] proxysql admin cli
select * from stats_mysql_processlist;
Empty set (0.00 sec)

普通查询，session 1 没断开，但后端连接已放回连接池，所以看不到processlist。下面试验临时表：

-- [session 1] mysql client proxysql
(ecdba@10.0.100.36:6033) [(none)]&gt; CREATE TEMPORARY TABLE db0.tbl_tmp(id int);
Query OK, 0 rows affected (0.18 sec)

-- [session 2] proxysql admin cli
(admin@127.0.0.1:6032) [(none)]&gt; select * from stats_mysql_processlist;
+----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+
| ThreadID | SessionID | user  | db                 | cli_host    | cli_port | hostgroup | l_srv_host  | l_srv_port | srv_host     | srv_port | command | time_ms | info |
+----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+
| 0        | 60        | ecdba | information_schema | 10.0.100.34 | 27058    | 100       | 10.0.100.36 | 41245      | 10.0.100.100 | 3307     | Sleep   | 4506    |      |
+----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+
1 row in set (0.00 sec)

看到后端的连接没有释放回连接池，但是在 session 1 里select却看不到刚才创建的临时表：

-- [session 1] 
(ecdba@10.0.100.36:6033) [(none)]&gt; select * from db0.tbl_tmp;
ERROR 1146 (42S02): Table &#39;db0.tbl_tmp&#39; doesn&#39;t exist

-- [session 2] 
(admin@127.0.0.1:6032) [(none)]&gt; select * from stats_mysql_processlist;
+----------+-----------+-------+--------------------+-------------+----------+-----------+------------+------------+----------+----------+---------+---------+------+
| ThreadID | SessionID | user  | db                 | cli_host    | cli_port | hostgroup | l_srv_host | l_srv_port | srv_host | srv_port | command | time_ms | info |
+----------+-----------+-------+--------------------+-------------+----------+-----------+------------+------------+----------+----------+---------+---------+------+
| 0        | 60        | ecdba | information_schema | 10.0.100.34 | 27058    | 1000      |            |            |          |          | Sleep   | 2002    |      |
+----------+-----------+-------+--------------------+-------------+----------+-----------+------------+------------+----------+----------+---------+---------+------+
1 row in set (0.00 sec)

select之后，发现上面的srv_host为空。下面往临时表里插数据，正常，且连接被 session 1 客户端持有：

-- [session 1] 
(ecdba@10.0.100.36:6033) [(none)]&gt; insert into db0.tbl_tmp values(1);
Query OK, 1 row affected (0.01 sec)

-- [session 2] 
(admin@127.0.0.1:6032) [(none)]&gt; select * from stats_mysql_processlist;
+----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+
| ThreadID | SessionID | user  | db                 | cli_host    | cli_port | hostgroup | l_srv_host  | l_srv_port | srv_host     | srv_port | command | time_ms | info |
+----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+
| 0        | 60        | ecdba | information_schema | 10.0.100.34 | 27058    | 100       | 10.0.100.36 | 41245      | 10.0.100.100 | 3307     | Sleep   | 2996    |      |
+----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+
1 row in set (0.00 sec)

-- [session 1] 
(ecdba@10.0.100.36:6033) [(none)]&gt; select 1;
+---+
| 1 |
+---+
| 1 |
+---+

-- [session 2] 
(admin@127.0.0.1:6032) [(none)]&gt; select * from stats_mysql_processlist;
+----------+-----------+-------+--------------------+-------------+----------+-----------+------------+------------+----------+----------+---------+---------+------+
| ThreadID | SessionID | user  | db                 | cli_host    | cli_port | hostgroup | l_srv_host | l_srv_port | srv_host | srv_port | command | time_ms | info |
+----------+-----------+-------+--------------------+-------------+----------+-----------+------------+------------+----------+----------+---------+---------+------+
| 0        | 60        | ecdba | information_schema | 10.0.100.34 | 27058    | 1000      |            |            |          |          | Sleep   | 2303    |      |
+----------+-----------+-------+--------------------+-------------+----------+-----------+------------+------------+----------+----------+---------+---------+------+
</code></pre><p>通过上面的过程可以看见，proxysql在遇到与会话本身相关的变量或操作时，自动禁用了multiplexing，并且针对整个会话有效，直到断开连接。另外，禁用了multiplexing，但<strong>路由规则依然生效</strong>，这就导致了select临时表时路由到了其它实例， Table xxx doesn&rsquo;t exist。</p>
<h2 id="2-显式start-transaction-验证3">2. 显式start transaction (验证3)<a hidden class="anchor" aria-hidden="true" href="#2-显式start-transaction-验证3">#</a></h2>
<p>第1,2点根据开发的习惯，都可以避免使用，但显式事务有时却不得不用，也做一个测试。</p>
<pre tabindex="0"><code>为了效果明显，我将一个不相干的实例，分配同一个hostgroup_id，权重1:1

-- [session 1] 
(ecdba@10.0.100.36:6033) [(none)]&gt; select * from db0.tbl_0;
+-----+----------+--------+
| fid | username | corpid |
+-----+----------+--------+
|   1 | db0 aa   |      0 |
|   2 | db0 aa   |     16 |
|   3 | db0 aa   |     32 |
+-----+----------+--------+

(ecdba@10.0.100.36:6033) [(none)]&gt; select * from db0.tbl_0;
ERROR 1146 (42S02): Table &#39;db0.tbl_0&#39; doesn&#39;t exist

(ecdba@10.0.100.36:6033) [(none)]&gt; begin;  -- 开启一个事务
(ecdba@10.0.100.36:6033) [(none)]&gt; select * from db0.tbl_0;
+-----+----------+--------+
| fid | username | corpid |
+-----+----------+--------+
|   1 | db0 aa   |      0 |
|   2 | db0 aa   |     16 |
|   3 | db0 aa   |     32 |
+-----+----------+--------+

(ecdba@10.0.100.36:6033) [(none)]&gt; select * from db0.tbl_0;
ERROR 1146 (42S02): Table &#39;db0.tbl_0&#39; doesn&#39;t exist

这就尴尬了，明显是在同一个事务里面，后端依然请求了多个backend。设置 transaction_persistent ：

-- [session 2] 
(admin@127.0.0.1:6032) [(none)]&gt; update mysql_users set transaction_persistent=1 where username=&#39;ecdba&#39;;
(admin@127.0.0.1:6032) [(none)]&gt; load mysql users to run;

-- [session 1] 
(ecdba@10.0.100.36:6033) [(none)]&gt; begin;
Query OK, 0 rows affected (0.00 sec)

(ecdba@10.0.100.36:6033) [(none)]&gt; select * from db0.tbl_0;
+-----+----------+--------+
| fid | username | corpid |
+-----+----------+--------+
|   1 | db0 aa   |      0 |
|   2 | db0 aa   |     16 |
|   3 | db0 aa   |     32 |
+-----+----------+--------+

反复执行多次还是上面的结果。 看到到后端连接的情况：
-- [session 2] 
(admin@127.0.0.1:6032) [(none)]&gt; select * from stats_mysql_processlist;
+----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+
| ThreadID | SessionID | user  | db                 | cli_host    | cli_port | hostgroup | l_srv_host  | l_srv_port | srv_host     | srv_port | command | time_ms | info |
+----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+
| 3        | 73        | ecdba | information_schema | 10.0.100.34 | 45030    | 100       | 10.0.100.36 | 6057       | 10.0.100.100 | 3307     | Sleep   | 43046   |      |
+----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+--------------+----------+---------+---------+------+
1 row in set (0.00 sec)
</code></pre><p>看到用户的 <code>transaction_persistent</code> 属性可以保证在同一个事务内的所有sql，都发向后端同一个db实例。如果它为0，同时一个hostgroup有多个可用slave，可能由于不同从库的延迟不一样，而查到不一致的数据。</p>
<p><code>transaction_persistent=1</code> 时还注意一下隐藏的一点点细节，begin 开启事务后，事务内所有语句包括select，都路由到了主库，这是因为 begin 匹配规则选择的是主库，后续的查询都跟着走;而 <code>transaction_persistent=0</code> 时 bgein 由于路由规则作用，也发到了主库，但后续的select,update等是不受它约束，继续根据路由规则走。在 非 <em>master-master</em> 模式下，事务还是安全的。</p>
<h2 id="31-autocommit-会话变量-验证4">3.1 autocommit 会话变量 (验证4)<a hidden class="anchor" aria-hidden="true" href="#31-autocommit-会话变量-验证4">#</a></h2>
<p>第 4 点略微有些复杂，开始之前先引用一段作者针对 issue <a href="https://github.com/sysown/proxysql/issues/653#issuecomment-241828093">#653</a> 的回复：（不完全翻译）</p>
<blockquote>
<p><strong>ProxySQL doesn&rsquo;t track user variable</strong><br>
ProxySQL不会记录 用户变量，当proxysql识别到 <code>set @variable1 = 67</code> 语句时，会自动禁用连接复用(disable multiplexing)，并根据路由规则选择后端节点（通常是写节点），执行完成后，连接不会放回连接池，直到disconnect。</p>
<p><strong>ProxySQL tracks some session variables</strong><br>
ProxySQL会记录 会话变量，“记录” 的意思是，proxysql接收到这些会话变量后，不会马上从后端连接池去拿连接然后 set xxx （因为还没有足够的信息知道拿哪个用户哪个db的连接），而是在当前连接保存起来，等待下一个查询命令，然后一起发送到到后端。<code>use dbname</code>就是这样处理的。
当前，记录的只有 <code>autocommit</code> 和字符集变量、<code>timezone</code>。比如执行sql前发送一个 <code>set autocommit=1</code>，proxysql会马上返回一个 <code>OK</code>，代表它知道应用端设置了自动提交，等真正的dml请求过来时，它将与后端拿到的连接比较autocommit是否匹配，不匹配则先set再执行dml。</p>
<p>当然现实还受到proxysql全局变量 <code>mysql-enforce_autocommit_on_reads</code> 的影响，即是否开启对读操作强制 autocommit。这个变量所解决的问题是，在同一个事务里既有 write 又有 read 且配置了读写分离的情况下，会导致在 读库 和 写库 各自开一个事务 (从库会set autocommit=0)，这就不合理了，所以把它设为 true 可以保证事务始终是一个。默认 false。
但是如上节所说，如果开启了 <code>transaction_persistent=1</code>，这个问题就不存在了。</p>
</blockquote>
<pre tabindex="0"><code>-- [session 1] 
(ecdba@10.0.100.36:6033) [(none)]&gt; set @variable1 = 67;

-- [session 2] 
(admin@127.0.0.1:6032) [(none)]&gt; show processlist;
+-----------+-------+--------------------+-----------+---------+---------+------+
| SessionID | user  | db                 | hostgroup | command | time_ms | info |
+-----------+-------+--------------------+-----------+---------+---------+------+
| 79        | ecdba | information_schema | 100       | Sleep   | 8008    |      |
+-----------+-------+--------------------+-----------+---------+---------+------+
1 row in set (0.00 sec)

与后端的连接已建立。但如果没有路由规则匹配到，proxysql会选择该用户 default_hostgroup，一般是0，由于没有 HG 0 记录，这个set variables会失败：
-- [session 1] 
(ecdba@10.0.100.36:6033) [(none)]&gt; set @variable1 = 67;
ERROR 9001 (HY000): Max connect timeout reached while reaching hostgroup 0 after 11462ms


同样情况下，set autocommit 和 set names 就很快返回，并且看不到后端有连接：
(ecdba@10.0.100.36:6033) [(none)]&gt; set session transaction isolation level read committed;
Query OK, 0 rows affected (0.00 sec)
(ecdba@10.0.100.36:6033) [(none)]&gt; set autocommit=0;
Query OK, 0 rows affected (0.00 sec)

-- [session 2] 
(admin@127.0.0.1:6032) [(none)]&gt; show processlist;
Empty set (0.00 sec)

-- [session 1] 
begin开启一个事务，验证 transaction_persistent：
(ecdba@10.0.100.36:6033) [(none)]&gt; UPDATE db0.tbl_0 set username=&#39;db0 autocommit&#39; where fid=3;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

(ecdba@10.0.100.36:6033) [(none)]&gt; select * from db0.tbl_0;
+-----+----------------+--------+
| fid | username       | corpid |
+-----+----------------+--------+
|   1 | db0 aa         |      0 |
|   2 | db0 aa         |     16 |
|   3 | db0 autocommit |     32 |
+-----+----------------+--------+
3 rows in set (0.00 sec)

(ecdba@10.0.100.36:6033) [(none)]&gt; commit;
Query OK, 0 rows affected (0.00 sec)

查看后端DB（主库）的 general_log：（都发到了主库）

		9651978 Connect	ecdba@10.0.100.36 on information_schema
		9651978 Query	SET autocommit=0
		9651978 Query	UPDATE db0.tbl_0 set username=&#39;db0 autocommit&#39; where fid=3
		9651978 Query	select * from db0.tbl_0
		9651978 Query	commit
</code></pre><p>这也告诉我们，尽量不要在 proxy admin cli 里面执行 show slave status， set global xxx 这样的管理命令，你较难预知到后端在哪里执行的。</p>
<h2 id="32-字符集prepared会话变量-验证4">3.2 字符集prepared会话变量 (验证4)<a hidden class="anchor" aria-hidden="true" href="#32-字符集prepared会话变量-验证4">#</a></h2>
<p>对字符集 <code>set NAMES xxx</code>, <code>set character_set_client=xxx</code>，处理方法与上面 set autocommit 是一样的，但是遇到使用 prepared statement 时需要特别提一下。</p>
<p>首先ProxySQL所支持的字符集，在表 <em>mysql_collations</em> 可以看到，它是直接从本地安装的mysql client lib获取的，proxysql默认使用的是utf8，指的是在连接的时候默认认为客户端的字符集是utf8。</p>
<p>根据 issue #780：https://github.com/sysown/proxysql/issues/780 的讨论，某些框架比如 Laravel 在通过PDO连接MySQL时，执行 prepared statement时会连同 <code>set NAMES xx</code> 一起发送，导致没有生效。经测试，该问题在 v1.3.5 中已不存在：</p>
<pre tabindex="0"><code>-- [session 1] 
mysql -uecweb -pweber -h10.0.100.34 -P6033 --default-character-set=latin1

(ecweb@10.0.100.34:6033) [(none)]&gt; select * from d_ec_crm.tttt;
+-----+-------+
| fid | fname |
+-----+-------+
|   1 | xx??? |
+-----+-------+

 latin1连接看utf8的数据，所以乱码。下面模拟 prepared statement 设置字符集：
(ecweb@10.0.100.34:6033) [(none)]&gt; PREPARE stmt FROM &#39;SET NAMES utf8&#39;;
Query OK, 0 rows affected (0.00 sec)
Statement prepared

-- [session 2] 
(admin@127.0.0.1:6032) [(none)]&gt; select * from stats_mysql_processlist;
+----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+---------------+----------+---------+---------+------+
| ThreadID | SessionID | user  | db                 | cli_host    | cli_port | hostgroup | l_srv_host  | l_srv_port | srv_host      | srv_port | command | time_ms | info |
+----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+---------------+----------+---------+---------+------+
| 1        | 50        | ecweb | information_schema | 10.0.100.34 | 46389    | 110       | 10.0.100.34 | 31946      | 192.168.1.229 | 3307     | Sleep   | 35649   |      |
+----------+-----------+-------+--------------------+-------------+----------+-----------+-------------+------------+---------------+----------+---------+---------+------+

直接执行还是乱码，也要在prepared ：
(ecweb@10.0.100.34:6033) [(none)]&gt; select * from d_ec_crm.tttt;
+-----+-------+
| fid | fname |
+-----+-------+
|   1 | xx??? |
+-----+-------+

(ecweb@10.0.100.34:6033) [(none)]&gt; PREPARE stmt FROM &#39;select * from d_ec_crm.tttt&#39;;
Query OK, 0 rows affected (0.00 sec)
Statement prepared

(ecweb@10.0.100.34:6033) [(none)]&gt; EXECUTE stmt;
+-----+-------------+
| fid | fname       |
+-----+-------------+
|   1 | xx嘻嘻嘻 |
+-----+-------------+
</code></pre><p>注意到 <code>PREPARE stmt FROM 'SET NAMES utf8'</code> 发送之后，马上与后端建立了连接，而不像上节<code>set names xx</code>止步于proxysql。所以是自动禁用了 multiplexing。</p>
<h2 id="33-set-sql_mode">3.3 set sql_mode<a hidden class="anchor" aria-hidden="true" href="#33-set-sql_mode">#</a></h2>
<p>作者明确表示 <code>sql_mode</code> 在 1.3.x 版本里不会track，也就是它完全按照路由规则走，不会像临时表或用户变量那样 disable multiplexing automaticly，也不像上面的会话变量那样 “记录” 然后一并发送。</p>
<p>如果sql_mode确实对应用使用造成困扰，1.4版本里会修复，在此前估计只好将连接复用的特性全局禁用：</p>
<pre tabindex="0"><code>SET mysql-multiplexing=&#39;false&#39;;
LOAD MYSQL VARIABLES TO RUNTIME;
SAVE MYSQL VARIABLES TO DISK;
</code></pre><p>参考 <a href="https://github.com/sysown/proxysql/issues/916">issue #916</a>。禁用 multiplexing 后，就像一般的中间件连接池一样，维持或者释放连接。</p>
<p>最后，关于 multiplexing 向作者提了一个特性 <a href="https://github.com/sysown/proxysql/issues/594#issuecomment-294703577">594#issuecomment-294703577</a> ：前端连接执行完一个查询，后端不马上把它返回连接池（复用），而是等待几秒，如果这个连接后续又有sql进来，就不需要重新从池里获取连接，还有检查一堆变量。renecannao 的回复非常及时，也确认 v1.4 会加上这个功能。</p>
<p>updated at 2017-07-27:
关于连接复用与连接池的差别，在后一次与作者的沟通中，更加明确了，见 <a href="https://github.com/sysown/proxysql/issues/1107">#issue 1107</a>:
问题始于发现环境中的connection pool没有起作用（禁用了multiplexing），因为一开始只是认为禁用了multiplexing，connection pool不会受影响。但实际不是的，在1.3.x版本里，禁用multiplexing，就相当于连接复用和连接池都没有了，前端应用在释放连接后，proxysql也把后端的连接释放了；在1.4.x版本里表现不同，禁用multiplexing后，前端连接释放，proxysql对后端的连接继续保持，并对连接重置以便重复利用。</p>
<p>所以如果测试上没啥问题，建议开启连接复用，或者升级到 1.4.x 版本。</p>
<hr>
<p>原文连接地址：http://xgknight.com/2017/04/17/mysql-proxysql-multiplexing/</p>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://xgknight.com/tags/mysql/">mysql</a></li>
      <li><a href="http://xgknight.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></li>
      <li><a href="http://xgknight.com/tags/proxysql/">proxysql</a></li>
    </ul>
  </footer><script src="https://utteranc.es/client.js"
        repo="seanlook/sean-notes-comment"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="http://xgknight.com/">Sean Note</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
