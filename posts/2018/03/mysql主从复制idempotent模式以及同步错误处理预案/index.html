<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>MySQL主从复制idempotent模式以及同步错误处理预案 | Sean Note</title>
<meta name="keywords" content="mysql, replication">
<meta name="description" content="1. slave_exec_mode 参数作用 slave_exec_mode 可以在主从复制中遇到 duplicate-key 和 no-key-found 错误时，自动覆盖或者略过binlog里面这个row_event，避免报错停止复制。
这个参数原本是解决像 NDB Cluster 多节点写入冲突的情况，也可以在普通主从、双主、环形复制等情况下解决冲突，保持幂等性。幂等性怎么定义，感兴趣的可以阅读The differences between IDEMPOTENT and AUTO-REPAIR mode）。
set global slave_exec_mode=IDEMPOTENT （可以动态修改）使从库运行在 幂等模式，对1062，1032等不同的错误类型，有不同的处理：
write_row event 遇到主键冲突或唯一索引冲突，这一行被覆写(delete &#43; insert)。 delete时候不是full value match，仅需要主键或唯一索引找到记录则删除 delete_row event 遇到记录不存在，忽略这一行 update_row event 修改唯一索引导致的冲突，忽略这一行 注意：
idempotent 模式都是对有疑问的行进行replace或ignore，不影响其它row。 idempotent 模式要求表上必须要有主键 binlog必须是 FULL RBR 模式 2. slave-skip-errors 这个参数不能在线修改，只能加到配置文件里面或者启动的时候带上--slave-skip-errors=1032,1062。除非你真的理解它skip掉了什么，否则不建议使用。
讲一个我所遇到的坑。在我们的一个分库项目中，需要把一个database里面的数据拆成32份，于是做了个主从，把从库里面不需要的那份删除，但复制过来肯定会报 HA_ERR_KEY_NOT_FOUND 错误，于是这也是所期望的，就设置了--slave-skip-errors=1032。
但接下来就出现 1062:HA_ERR_FOUND_DUPP_KEY 错误！从库只会删数据，不会写入和更新，怎么会出现重复数据？读者不妨试想一下为什么。
这里做个说明：
① insert into t values (1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;); ② begin; ③ delete from t where id=1; ④ delete from t where id in (1, 2, 3); ⑤ insert into t where (3, &#39;c&#39;), (4, &#39;d&#39;), (5, &#39;e&#39;); ⑥ update t set .">
<meta name="author" content="admin">
<link rel="canonical" href="http://xgknight.com/posts/2018/03/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6idempotent%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%90%8C%E6%AD%A5%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E9%A2%84%E6%A1%88/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css" integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://xgknight.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://xgknight.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://xgknight.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://xgknight.com/apple-touch-icon.png">
<link rel="mask-icon" href="http://xgknight.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="MySQL主从复制idempotent模式以及同步错误处理预案" />
<meta property="og:description" content="1. slave_exec_mode 参数作用 slave_exec_mode 可以在主从复制中遇到 duplicate-key 和 no-key-found 错误时，自动覆盖或者略过binlog里面这个row_event，避免报错停止复制。
这个参数原本是解决像 NDB Cluster 多节点写入冲突的情况，也可以在普通主从、双主、环形复制等情况下解决冲突，保持幂等性。幂等性怎么定义，感兴趣的可以阅读The differences between IDEMPOTENT and AUTO-REPAIR mode）。
set global slave_exec_mode=IDEMPOTENT （可以动态修改）使从库运行在 幂等模式，对1062，1032等不同的错误类型，有不同的处理：
write_row event 遇到主键冲突或唯一索引冲突，这一行被覆写(delete &#43; insert)。 delete时候不是full value match，仅需要主键或唯一索引找到记录则删除 delete_row event 遇到记录不存在，忽略这一行 update_row event 修改唯一索引导致的冲突，忽略这一行 注意：
idempotent 模式都是对有疑问的行进行replace或ignore，不影响其它row。 idempotent 模式要求表上必须要有主键 binlog必须是 FULL RBR 模式 2. slave-skip-errors 这个参数不能在线修改，只能加到配置文件里面或者启动的时候带上--slave-skip-errors=1032,1062。除非你真的理解它skip掉了什么，否则不建议使用。
讲一个我所遇到的坑。在我们的一个分库项目中，需要把一个database里面的数据拆成32份，于是做了个主从，把从库里面不需要的那份删除，但复制过来肯定会报 HA_ERR_KEY_NOT_FOUND 错误，于是这也是所期望的，就设置了--slave-skip-errors=1032。
但接下来就出现 1062:HA_ERR_FOUND_DUPP_KEY 错误！从库只会删数据，不会写入和更新，怎么会出现重复数据？读者不妨试想一下为什么。
这里做个说明：
① insert into t values (1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;); ② begin; ③ delete from t where id=1; ④ delete from t where id in (1, 2, 3); ⑤ insert into t where (3, &#39;c&#39;), (4, &#39;d&#39;), (5, &#39;e&#39;); ⑥ update t set ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://xgknight.com/posts/2018/03/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6idempotent%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%90%8C%E6%AD%A5%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E9%A2%84%E6%A1%88/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-11T16:32:49+00:00" />
<meta property="article:modified_time" content="2018-03-11T16:32:49+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MySQL主从复制idempotent模式以及同步错误处理预案"/>
<meta name="twitter:description" content="1. slave_exec_mode 参数作用 slave_exec_mode 可以在主从复制中遇到 duplicate-key 和 no-key-found 错误时，自动覆盖或者略过binlog里面这个row_event，避免报错停止复制。
这个参数原本是解决像 NDB Cluster 多节点写入冲突的情况，也可以在普通主从、双主、环形复制等情况下解决冲突，保持幂等性。幂等性怎么定义，感兴趣的可以阅读The differences between IDEMPOTENT and AUTO-REPAIR mode）。
set global slave_exec_mode=IDEMPOTENT （可以动态修改）使从库运行在 幂等模式，对1062，1032等不同的错误类型，有不同的处理：
write_row event 遇到主键冲突或唯一索引冲突，这一行被覆写(delete &#43; insert)。 delete时候不是full value match，仅需要主键或唯一索引找到记录则删除 delete_row event 遇到记录不存在，忽略这一行 update_row event 修改唯一索引导致的冲突，忽略这一行 注意：
idempotent 模式都是对有疑问的行进行replace或ignore，不影响其它row。 idempotent 模式要求表上必须要有主键 binlog必须是 FULL RBR 模式 2. slave-skip-errors 这个参数不能在线修改，只能加到配置文件里面或者启动的时候带上--slave-skip-errors=1032,1062。除非你真的理解它skip掉了什么，否则不建议使用。
讲一个我所遇到的坑。在我们的一个分库项目中，需要把一个database里面的数据拆成32份，于是做了个主从，把从库里面不需要的那份删除，但复制过来肯定会报 HA_ERR_KEY_NOT_FOUND 错误，于是这也是所期望的，就设置了--slave-skip-errors=1032。
但接下来就出现 1062:HA_ERR_FOUND_DUPP_KEY 错误！从库只会删数据，不会写入和更新，怎么会出现重复数据？读者不妨试想一下为什么。
这里做个说明：
① insert into t values (1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;); ② begin; ③ delete from t where id=1; ④ delete from t where id in (1, 2, 3); ⑤ insert into t where (3, &#39;c&#39;), (4, &#39;d&#39;), (5, &#39;e&#39;); ⑥ update t set ."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://xgknight.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "MySQL主从复制idempotent模式以及同步错误处理预案",
      "item": "http://xgknight.com/posts/2018/03/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6idempotent%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%90%8C%E6%AD%A5%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E9%A2%84%E6%A1%88/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL主从复制idempotent模式以及同步错误处理预案",
  "name": "MySQL主从复制idempotent模式以及同步错误处理预案",
  "description": "1. slave_exec_mode 参数作用 slave_exec_mode 可以在主从复制中遇到 duplicate-key 和 no-key-found 错误时，自动覆盖或者略过binlog里面这个row_event，避免报错停止复制。\n这个参数原本是解决像 NDB Cluster 多节点写入冲突的情况，也可以在普通主从、双主、环形复制等情况下解决冲突，保持幂等性。幂等性怎么定义，感兴趣的可以阅读The differences between IDEMPOTENT and AUTO-REPAIR mode）。\nset global slave_exec_mode=IDEMPOTENT （可以动态修改）使从库运行在 幂等模式，对1062，1032等不同的错误类型，有不同的处理：\nwrite_row event 遇到主键冲突或唯一索引冲突，这一行被覆写(delete + insert)。 delete时候不是full value match，仅需要主键或唯一索引找到记录则删除 delete_row event 遇到记录不存在，忽略这一行 update_row event 修改唯一索引导致的冲突，忽略这一行 注意：\nidempotent 模式都是对有疑问的行进行replace或ignore，不影响其它row。 idempotent 模式要求表上必须要有主键 binlog必须是 FULL RBR 模式 2. slave-skip-errors 这个参数不能在线修改，只能加到配置文件里面或者启动的时候带上--slave-skip-errors=1032,1062。除非你真的理解它skip掉了什么，否则不建议使用。\n讲一个我所遇到的坑。在我们的一个分库项目中，需要把一个database里面的数据拆成32份，于是做了个主从，把从库里面不需要的那份删除，但复制过来肯定会报 HA_ERR_KEY_NOT_FOUND 错误，于是这也是所期望的，就设置了--slave-skip-errors=1032。\n但接下来就出现 1062:HA_ERR_FOUND_DUPP_KEY 错误！从库只会删数据，不会写入和更新，怎么会出现重复数据？读者不妨试想一下为什么。\n这里做个说明：\n① insert into t values (1, \u0026#39;a\u0026#39;), (2, \u0026#39;b\u0026#39;), (3, \u0026#39;c\u0026#39;); ② begin; ③ delete from t where id=1; ④ delete from t where id in (1, 2, 3); ⑤ insert into t where (3, \u0026#39;c\u0026#39;), (4, \u0026#39;d\u0026#39;), (5, \u0026#39;e\u0026#39;); ⑥ update t set .",
  "keywords": [
    "mysql", "replication"
  ],
  "articleBody": "1. slave_exec_mode 参数作用 slave_exec_mode 可以在主从复制中遇到 duplicate-key 和 no-key-found 错误时，自动覆盖或者略过binlog里面这个row_event，避免报错停止复制。\n这个参数原本是解决像 NDB Cluster 多节点写入冲突的情况，也可以在普通主从、双主、环形复制等情况下解决冲突，保持幂等性。幂等性怎么定义，感兴趣的可以阅读The differences between IDEMPOTENT and AUTO-REPAIR mode）。\nset global slave_exec_mode=IDEMPOTENT （可以动态修改）使从库运行在 幂等模式，对1062，1032等不同的错误类型，有不同的处理：\nwrite_row event 遇到主键冲突或唯一索引冲突，这一行被覆写(delete + insert)。 delete时候不是full value match，仅需要主键或唯一索引找到记录则删除 delete_row event 遇到记录不存在，忽略这一行 update_row event 修改唯一索引导致的冲突，忽略这一行 注意：\nidempotent 模式都是对有疑问的行进行replace或ignore，不影响其它row。 idempotent 模式要求表上必须要有主键 binlog必须是 FULL RBR 模式 2. slave-skip-errors 这个参数不能在线修改，只能加到配置文件里面或者启动的时候带上--slave-skip-errors=1032,1062。除非你真的理解它skip掉了什么，否则不建议使用。\n讲一个我所遇到的坑。在我们的一个分库项目中，需要把一个database里面的数据拆成32份，于是做了个主从，把从库里面不需要的那份删除，但复制过来肯定会报 HA_ERR_KEY_NOT_FOUND 错误，于是这也是所期望的，就设置了--slave-skip-errors=1032。\n但接下来就出现 1062:HA_ERR_FOUND_DUPP_KEY 错误！从库只会删数据，不会写入和更新，怎么会出现重复数据？读者不妨试想一下为什么。\n这里做个说明：\n① insert into t values (1, 'a'), (2, 'b'), (3, 'c'); ② begin; ③ delete from t where id=1; ④ delete from t where id in (1, 2, 3); ⑤ insert into t where (3, 'c'), (4, 'd'), (5, 'e'); ⑥ update t set ... id=1; ⑦ commit; 事务包括显式事务和隐式事务(transaction)，语句①落在binlog里面也会有begin和end 一个事物可以包含多个语句(statement) 一个语句可以影响多行(row)，但属于一个event 一个语句在binlog里面有多个event (row log event, table map event, xid event…) event在binlog里面以 event group 组合起来\n事务引擎如 InnoDB，event group 就一个事务；非事务引擎如 MyISAM，event group就是一条语句 slave-skip-errors 参数作用的是 statement，上面的slave_exec_mode作用的是row 比如上面那段sql在RBR复制到从库时发现④的 id=2 不存在：\nslave_exec_mode: ④里面的 id=2 略过，id=1,3 正常删除，事务里其它sql(row event)都正常重放\nslave-skip-errors=1032: 从库也会一直从 begin 执行到 end ，但④里面的 id=3 会跳过（跳过的是这个statement，而 id=1 会依然删除，不是原子操作），事务里其它sql正常重放。\n这就导致了我上面那个问题，id=3应该是被删除的但被跳过，下面在插入 id=3 的记录就 1062 了。如果再把 1062 也加入到 skip-errors，那么数据肯定会出现的丢失，是不可取的。\n相关验证可以看后文。\n3. sql_slave_skip_counter MySQL主从复制出现异常的时候，如不及时处理，延迟的时间会越来越长，所以有时候哪怕允许极少量的数据不一致，也要让数据继续同步，往往会用到 sql_slave_skip_counter 参数来跳过异常事件。 用法:\nmysql\u003e show slave status\\G -- 1062可以看到是哪条记录重复 mysql\u003e slave stop; mysql\u003e set GLOBAL SQL_SLAVE_SKIP_COUNTER=1; mysql\u003e slave start; sql_slave_skip_counter=1\n跳过一个 event group。前面讲到对InnoDB而言，就是跳过一个事务。 如果当前 binlog postion 落在 event group 中间，那么就一直跳到这个事务末尾。 sql_slave_skip_counter=N (N\u003e1)\n跳过 N 个 event。对不同的binlog版本会加入不同的event类型。\n比如上图在 pos 199 出现error，如果设置 set global sql_slave_skip_counter=3，那么就会以此跳过 199,264,332，每跳过一个 Skip_Counter 减去1，减到 Skip_Counter=1 的时候，如果pos还在事务中间，那么那么就一直跳到该事务末尾。 (同样，在事务中出现异常之前的修改，不会回滚) 4. GTID复制异常处理 主从开启了GTID（select @@gtid_mode），就不能再用 sql_slave_skip_counter 来跳过错误，需要注册一个空gtid event来代替原本执行报错的event。比如：\nmysql\u003e show slave status\\G *************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 10.153.173.149 Master_User: replicator Master_Port: 3027 Connect_Retry: 60 Master_Log_File: mysql-bin.014670 Read_Master_Log_Pos: 181716556 Relay_Log_File: slave-relay.028871 Relay_Log_Pos: 166693104 Relay_Master_Log_File: mysql-bin.014670 Slave_IO_Running: Yes Slave_SQL_Running: No Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 1032 Last_Error: Could not execute Update_rows event on table mysql.user; Can't find record in 'user', Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event's master log mysql-bin.014670, end_log_pos 166693925 Skip_Counter: 0 Exec_Master_Log_Pos: 166692941 Relay_Log_Space: 688 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: NULL Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 1032 Last_SQL_Error: Could not execute Update_rows event on table mysql.user; Can't find record in 'user', Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event's master log mysql-bin.014670, end_log_pos 166693925 Replicate_Ignore_Server_Ids: Master_Server_Id: 1088575531 Master_UUID: 108f89d5-d74f-11e7-942f-7cd30ac4755e Master_Info_File: mysql.slave_master_info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it Master_Retry_Count: 86400 Master_Bind: Last_IO_Error_Timestamp: Last_SQL_Error_Timestamp: Master_SSL_Crl: Master_SSL_Crlpath: Retrieved_Gtid_Set: 108f89d5-d74f-11e7-942f-7cd30ac4755e:8077-122925776 Executed_Gtid_Set: 108f89d5-d74f-11e7-942f-7cd30ac4755e:1-122925773, 8b101f33-f327-11e7-89c3-7cd30ac333bc:1-1425, fba62795-d74e-11e7-942e-7cd30ac4e7fc:1-630905526 Auto_Position: 0 1 row in set (0.00 sec) 跳过处理：\nmysql\u003e stop slave; mysql\u003e set gtid_next='108f89d5-d74f-11e7-942f-7cd30ac4755e:122925774'; mysql\u003e begin; commit; -- empty trx mysql\u003e set gtid_next='AUTOMATIC'; -- auto position mysql\u003e start slave; 上面 gtid_next 的值 108f89d5-d74f-11e7-942f-7cd30ac4755e:122925774 是个会话级变量。\nuuid是 Retrieved_Gtid_Set 的uuid，一般是 Master_UUID 的值，但如果是级联复制(master -\u003e slavel1 -\u003e slave2)，那么要找到出错事务最原先在哪执行的 trx_id(或叫position)是 master 上正常执行的最大id + 1，即Executed_Gtid_Set里面master uuid执行过的最大值 122925773 + 1 5. pt-slave-restart pt-slave-restart 可以快速方便的恢复主从复制错误，并且支持普通 file:postion 和 GTID 模式。\n修复的原理就是运行上面的 sql_slave_skip_counter 和 gtid_next，只是它可以自动的帮DBA识别错误码，或者匹配error_msg，stop/start slave，并且默认情况下它是一直运行 检测+修复。\npt-slave-restart --user=dbuser --password=xxxx --socket=/var/lib/mysql/mysql.sock --error-numbers=1032,1677,1051 几点说明一下：\n--sleep\npt-slave-restart 循环检查 show slave status 的间隔时间。如果发现有异常，下次sleep time将减半，因为它假设当前有异常，那么下一个event很有可能也异常。\n--master_uuid\n级联复制下指定了 master_uuid 才能知道事件原始来自于哪里，好让pt-slave-restart知道在哪个 max_trx_id 上面 + 1。\n在gtid模式下，pt-slave-restart 不能用在多线程复制下（即 slave_parallel_workers\u003e0），因为它不知道这个GTID错误是从库哪个sql线程产生的。\n以上所有处理错误的方法，在跳过后，都需要进行数据一致性修复(pt-table-sync)，或者重做从库。\n6. 手动处理复制错误并修复 这种处理思路是写程序实现，遇到1032错误，在主库Binlog里面解析出before image，在从库插入，再stop/start slave；遇到1062错误，在从库删除这条数据（可以根据主库binlog after image取数据，也可以根据duplicate key中提示的重复记录），再stop/start/slave。\n不需要skip操作，也不需要后续修复数据（只是不会因为有跳过event而产生不一致），如果从主库拿binl log或者从库拿relay log有困难，也可使用 pymysql-replication 来伪装成从库拿到出错的 binlog postion 的内容，解析再用。\n当然为保险起见，已经出现不一致的还是要 pt-table-checksum 跑一下。\n7. 附: 测试 slave_skip_errors, slave_exec_mode CREATE TABLE `t_repl_test` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(30) DEFAULT NULL, `age` int(11) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `uk_name` (`name`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 insert into t_repl_test values(1,'a',10), (2,'b',20), (3,'c',30), (4,'d',40),(5,'e',50); # 初始化测试数据 # master: delete from t_repl_test where id=2; # slave: delete from t_repl_test where id=3; insert into t_repl_test values(2,'b',20); 每次测试前，数据都初始化成下面的：\n7.1 delete 测试 1. slave_skip_errors=1032,1062\nslave:\nmysql\u003e select @@slave_skip_errors, @@slave_exec_mode; +---------------------+-------------------+ | @@slave_skip_errors | @@slave_exec_mode | +---------------------+-------------------+ | 1032,1062 | STRICT | +---------------------+-------------------+ 1 row in set (0.00 sec) mysql\u003e delete from t_repl_test where id in (1,3,4); Query OK, 3 rows affected (0.00 sec)\nmysql\u003e delete from t_repl_test where id in (5); Query OK, 1 row affected (0.01 sec)\nmysql\u003e commit; Query OK, 0 rows affected (0.00 sec) 在从库，1和5被删除，4被跳过了，skip_error=1032作用在statement上，并且已经部分成功了的statement 不会回滚。\n2. slave_exec_mode=IDEMPOTENT\n复原。不是设置skip, 设置idempotent， slave:\nmysql\u003e select @@slave_skip_errors, @@slave_exec_mode; +---------------------+-------------------+ | @@slave_skip_errors | @@slave_exec_mode | +---------------------+-------------------+ | OFF | IDEMPOTENT | +---------------------+-------------------+ mysql\u003e select * from t_repl_test; +----+------+------+ | id | name | age | +----+------+------+ | 2 | b | 20 | +----+------+------+ 这次1, 4, 5都被删除，也就是4是一个 statement 里面某一个row_event，没有受到 id=3 error 1032的影响。\n注意\n如果slave同时设置 slave_skip_errors 和 slave_exec_mode，那么优先生效的是 slave_skip_errors。\n7.2 insert 1. slave_skip_errors=1032,1062 slave_exec_mode=STRICT\nmysql\u003e insert into t_repl_test values(8,‘h’,80); Query OK, 1 row affected (0.01 sec)\nmysql\u003e commit; mysql\u003e select * from t_repl_test; +—-+——+——+ | id | name | age | +—-+——+——+ | 1 | a | 10 | | 2 | b | 20 | | 4 | d | 40 | | 5 | e | 50 | | 6 | f | 60 | | 8 | h | 80 | +—-+——+——+\n6成功，2和7失败，8成功。与delete作用范围一致。\n2. slave_skip_errors=OFF slave_exec_mode=IDEMPOTENT\nslave:\nmysql\u003e select @@slave_skip_errors, @@slave_exec_mode; +---------------------+-------------------+ | @@slave_skip_errors | @@slave_exec_mode | +---------------------+-------------------+ | OFF | IDEMPOTENT | +---------------------+-------------------+ mysql\u003e select * from t_repl_test; +----+------+------+ | id | name | age | +----+------+------+ | 1 | a | 10 | | 2 | bb | 200 | | 4 | d | 40 | | 5 | e | 50 | | 6 | f | 60 | | 7 | g | 70 | | 8 | h | 80 | +----+------+------+ 6, 7, 8 都插入成功，id=2的id=2被更新。所以从库在 idempotent 模式下遇到1062，是replace操作。\n3. slave_skip_errors=OFF slave_exec_mode=IDEMPOTENT unique_key\n再来看一个好玩的（id是主键，name是唯一索引）: 从库应用relay log遇到 Duplicate entry 错误有不同处理动作。\nmysql\u003e insert into t_repl_test values(9,‘b’,200); Query OK, 1 row affected (0.00 sec)\nmysql\u003e update t_repl_test set name=‘e’ where id=4; Query OK, 1 row affected (0.01 sec) Rows matched: 1 Changed: 1 Warnings: 0\nmysql\u003e select * from t_repl_test; +—-+——+——+ | id | name | age | +—-+——+——+ | 1 | a | 10 | | 3 | c | 30 | | 4 | e | 40 | | 9 | b | 200 | +—-+——+——+ 4 rows in set (0.00 sec) mysql\u003e select * from t_repl_test; +—-+——+——+ | id | name | age | +—-+——+——+ | 1 | a | 10 | | 4 | d | 40 | | 5 | e | 50 | | 9 | b | 200 | +—-+——+——+ 4 rows in set (0.00 sec)\n第一条 insert 值在从库上 name=b 已经存在，违反唯一约束，所以被 replace 掉了。\n第二条 update 值在从库上 name=e 已经存在，违反唯一约束，在从库 被忽略 了。看从从库的imdepotent错误日志:\n2018-02-02 14:50:35 24325 [Warning] Slave SQL: Could not execute Update_rows event on table d_ec_crmlog.t_repl_test; Duplicate entry 'e' for key 'uk_name', Error_code: 1062; handler error HA_ERR_FOUND_DUPP_KEY; the event's master log mysql-bin.000015, end_log_pos 27072, Error_code: 1062 为什么会有这个行为，可以从源码里面找到答案：\nWrite_rows_log_event::do_before_row_operations() if ((slave_exec_mode == SLAVE_EXEC_MODE_IDEMPOTENT) || (m_table-\u003es-\u003edb_type()-\u003edb_type == DB_TYPE_NDBCLUSTER)) { /* We are using REPLACE semantics and not INSERT IGNORE semantics when writing rows, that is: new rows replace old rows. We need to inform the storage engine that it should use this behaviour. */ /* Tell the storage engine that we are using REPLACE semantics. */ thd-\u003elex-\u003eduplicates= DUP_REPLACE; /* Pretend we're executing a REPLACE command: this is needed for InnoDB and NDB Cluster since they are not (properly) checking the lex-\u003eduplicates flag. */ thd-\u003elex-\u003esql_command= SQLCOM_REPLACE; /* Do not raise the error flag in case of hitting to an unique attribute */ m_table-\u003efile-\u003eextra(HA_EXTRA_IGNORE_DUP_KEY); ... } 本文链接地址：http://xgknight.com/2018/03/11/mysql-replication-error-and-idempotent/\n",
  "wordCount" : "1146",
  "inLanguage": "en",
  "datePublished": "2018-03-11T16:32:49Z",
  "dateModified": "2018-03-11T16:32:49Z",
  "author":{
    "@type": "Person",
    "name": "admin"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://xgknight.com/posts/2018/03/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6idempotent%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%90%8C%E6%AD%A5%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E9%A2%84%E6%A1%88/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sean Note",
    "logo": {
      "@type": "ImageObject",
      "url": "http://xgknight.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://xgknight.com/" accesskey="h" title="Sean Note (Alt + H)">Sean Note</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://xgknight.com/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://xgknight.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      MySQL主从复制idempotent模式以及同步错误处理预案
    </h1>
    <div class="post-meta"><span title='2018-03-11 16:32:49 +0000 UTC'>March 11, 2018</span>&nbsp;·&nbsp;admin

</div>
  </header> 
  <div class="post-content"><h1 id="1-slave_exec_mode-参数作用">1. slave_exec_mode 参数作用<a hidden class="anchor" aria-hidden="true" href="#1-slave_exec_mode-参数作用">#</a></h1>
<p><code>slave_exec_mode</code> 可以在主从复制中遇到 duplicate-key 和 no-key-found 错误时，自动覆盖或者略过binlog里面这个row_event，避免报错停止复制。</p>
<p>这个参数原本是解决像 NDB Cluster 多节点写入冲突的情况，也可以在普通主从、双主、环形复制等情况下解决冲突，保持幂等性。幂等性怎么定义，感兴趣的可以阅读<a href="http://http://blog.wl0.org/2016/05/the-differences-between-idempotent-and-my-suggested-auto-repair-mode/">The differences between IDEMPOTENT and AUTO-REPAIR mode</a>）。</p>
<p><code>set global slave_exec_mode=IDEMPOTENT</code> （可以动态修改）使从库运行在 幂等模式，对1062，1032等不同的错误类型，有不同的处理：</p>
<ol>
<li>write_row event 遇到主键冲突或唯一索引冲突，这一行被覆写(delete + insert)。
delete时候不是full value match，仅需要主键或唯一索引找到记录则删除</li>
<li>delete_row event 遇到记录不存在，忽略这一行</li>
<li>update_row event 修改唯一索引导致的冲突，忽略这一行</li>
</ol>
<p>注意：</p>
<ul>
<li>idempotent 模式都是对有疑问的<strong>行</strong>进行replace或ignore，不影响其它row。</li>
<li>idempotent 模式要求表上必须要有主键</li>
<li>binlog必须是 FULL RBR 模式</li>
</ul>
<h1 id="2-slave-skip-errors">2. slave-skip-errors<a hidden class="anchor" aria-hidden="true" href="#2-slave-skip-errors">#</a></h1>
<p>这个参数不能在线修改，只能加到配置文件里面或者启动的时候带上<code>--slave-skip-errors=1032,1062</code>。除非你真的理解它skip掉了什么，否则不建议使用。</p>
<p>讲一个我所遇到的坑。在我们的一个分库项目中，需要把一个database里面的数据拆成32份，于是做了个主从，把从库里面不需要的那份删除，但复制过来肯定会报 HA_ERR_KEY_NOT_FOUND 错误，于是这也是所期望的，就设置了<code>--slave-skip-errors=1032</code>。</p>
<p>但接下来就出现 1062:HA_ERR_FOUND_DUPP_KEY 错误！从库只会删数据，不会写入和更新，怎么会出现重复数据？读者不妨试想一下为什么。</p>
<p>这里做个说明：</p>
<pre tabindex="0"><code>① insert into t values (1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;);

② begin;
③ delete from t where id=1;
④ delete from t where id in (1, 2, 3);
⑤ insert into t where (3, &#39;c&#39;), (4, &#39;d&#39;), (5, &#39;e&#39;);
⑥ update t set ... id=1;
⑦ commit;
</code></pre><ul>
<li>事务包括显式事务和隐式事务(transaction)，语句①落在binlog里面也会有begin和end</li>
<li>一个事物可以包含多个语句(statement)</li>
<li>一个语句可以影响多行(row)，但属于一个event</li>
<li>一个语句在binlog里面有多个event (row log event, table map event, xid event&hellip;)</li>
<li>event在binlog里面以 event group 组合起来<br>
事务引擎如 InnoDB，event group 就一个事务；非事务引擎如 MyISAM，event group就是一条语句</li>
</ul>
<!-- raw HTML omitted -->
<p><strong>slave-skip-errors 参数作用的是 statement，上面的slave_exec_mode作用的是row</strong>
比如上面那段sql在RBR复制到从库时发现④的 id=2 不存在：</p>
<ul>
<li>
<p><code>slave_exec_mode</code>: ④里面的 id=2 略过，id=1,3 正常删除，事务里其它sql(row event)都正常重放</p>
</li>
<li>
<p><code>slave-skip-errors=1032</code>: 从库也会一直从 begin 执行到 end ，但④里面的 id=3 会跳过（跳过的是这个statement，而 id=1 会依然删除，不是原子操作），事务里其它sql正常重放。</p>
<p>这就导致了我上面那个问题，id=3应该是被删除的但被跳过，下面在插入 id=3 的记录就 1062 了。如果再把 1062 也加入到 skip-errors，那么数据肯定会出现的丢失，是不可取的。</p>
</li>
</ul>
<p>相关验证可以看后文。</p>
<h1 id="3-sql_slave_skip_counter">3. sql_slave_skip_counter<a hidden class="anchor" aria-hidden="true" href="#3-sql_slave_skip_counter">#</a></h1>
<p>MySQL主从复制出现异常的时候，如不及时处理，延迟的时间会越来越长，所以有时候哪怕允许极少量的数据不一致，也要让数据继续同步，往往会用到 <code>sql_slave_skip_counter</code> 参数来跳过异常事件。
用法:</p>
<pre tabindex="0"><code>mysql&gt; show slave status\G -- 1062可以看到是哪条记录重复

mysql&gt; slave stop;
mysql&gt; set GLOBAL SQL_SLAVE_SKIP_COUNTER=1;
mysql&gt; slave start;
</code></pre><ul>
<li>sql_slave_skip_counter=1<br>
跳过一个 event group。前面讲到对InnoDB而言，就是<strong>跳过一个事务</strong>。
如果当前 binlog postion 落在 event group 中间，那么就一直跳到这个事务末尾。</li>
<li>sql_slave_skip_counter=N (N&gt;1)<br>
跳过 N 个 event。对不同的binlog版本会加入不同的event类型。<br>
<img loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/slave_error_binlog_events.png" alt="slave_error_binlog_events"  />
<br>
比如上图在 pos 199 出现error，如果设置 <code>set global sql_slave_skip_counter=3</code>，那么就会以此跳过 199,264,332，每跳过一个 Skip_Counter 减去1，减到 Skip_Counter=1 的时候，如果pos还在<strong>事务</strong>中间，那么那么就一直跳到该事务末尾。
(同样，在事务中出现异常之前的修改，不会回滚)</li>
</ul>
<h1 id="4-gtid复制异常处理">4. GTID复制异常处理<a hidden class="anchor" aria-hidden="true" href="#4-gtid复制异常处理">#</a></h1>
<p>主从开启了GTID（<code>select @@gtid_mode</code>），就不能再用 sql_slave_skip_counter 来跳过错误，需要注册一个空gtid event来代替原本执行报错的event。比如：</p>
<pre tabindex="0"><code>mysql&gt; show slave status\G
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 10.153.173.149
                  Master_User: replicator
                  Master_Port: 3027
                Connect_Retry: 60
              Master_Log_File: mysql-bin.014670
          Read_Master_Log_Pos: 181716556
               Relay_Log_File: slave-relay.028871
                Relay_Log_Pos: 166693104
        Relay_Master_Log_File: mysql-bin.014670
             Slave_IO_Running: Yes
            Slave_SQL_Running: No
              Replicate_Do_DB: 
          Replicate_Ignore_DB: 
           Replicate_Do_Table: 
       Replicate_Ignore_Table: 
      Replicate_Wild_Do_Table: 
  Replicate_Wild_Ignore_Table: 
                   Last_Errno: 1032
                   Last_Error: Could not execute Update_rows event on table mysql.user; Can&#39;t find record in &#39;user&#39;, Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event&#39;s master log mysql-bin.014670, end_log_pos 166693925
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 166692941
              Relay_Log_Space: 688
              Until_Condition: None
               Until_Log_File: 
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File: 
           Master_SSL_CA_Path: 
              Master_SSL_Cert: 
            Master_SSL_Cipher: 
               Master_SSL_Key: 
        Seconds_Behind_Master: NULL
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error: 
               Last_SQL_Errno: 1032
               Last_SQL_Error: Could not execute Update_rows event on table mysql.user; Can&#39;t find record in &#39;user&#39;, Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event&#39;s master log mysql-bin.014670, end_log_pos 166693925 
  Replicate_Ignore_Server_Ids: 
             Master_Server_Id: 1088575531
                  Master_UUID: 108f89d5-d74f-11e7-942f-7cd30ac4755e
             Master_Info_File: mysql.slave_master_info
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
      Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it
           Master_Retry_Count: 86400
                  Master_Bind: 
      Last_IO_Error_Timestamp: 
     Last_SQL_Error_Timestamp: 
               Master_SSL_Crl: 
           Master_SSL_Crlpath: 
           Retrieved_Gtid_Set: 108f89d5-d74f-11e7-942f-7cd30ac4755e:8077-122925776
            Executed_Gtid_Set: 108f89d5-d74f-11e7-942f-7cd30ac4755e:1-122925773,
8b101f33-f327-11e7-89c3-7cd30ac333bc:1-1425,
fba62795-d74e-11e7-942e-7cd30ac4e7fc:1-630905526
                Auto_Position: 0
1 row in set (0.00 sec)
</code></pre><p>跳过处理：</p>
<pre tabindex="0"><code>mysql&gt; stop slave;
mysql&gt; set gtid_next=&#39;108f89d5-d74f-11e7-942f-7cd30ac4755e:122925774&#39;;
mysql&gt; begin; commit;  -- empty trx
mysql&gt; set gtid_next=&#39;AUTOMATIC&#39;;  -- auto position
mysql&gt; start slave;
</code></pre><p>上面 gtid_next 的值 <code>108f89d5-d74f-11e7-942f-7cd30ac4755e:122925774</code> 是个会话级变量。</p>
<ul>
<li>uuid是 <code>Retrieved_Gtid_Set</code> 的uuid，一般是 <code>Master_UUID</code> 的值，但如果是级联复制(master -&gt; slavel1 -&gt; slave2)，那么要找到出错事务最原先在哪执行的</li>
<li>trx_id(或叫position)是 master 上正常执行的最大id + 1，即<code>Executed_Gtid_Set</code>里面master uuid执行过的最大值 122925773 + 1</li>
</ul>
<h1 id="5-pt-slave-restart">5. pt-slave-restart<a hidden class="anchor" aria-hidden="true" href="#5-pt-slave-restart">#</a></h1>
<p>pt-slave-restart 可以快速方便的恢复主从复制错误，并且支持普通 file:postion 和 GTID 模式。</p>
<p>修复的原理就是运行上面的 <code>sql_slave_skip_counter</code> 和 <code>gtid_next</code>，只是它可以自动的帮DBA识别错误码，或者匹配error_msg，stop/start slave，并且默认情况下它是一直运行 检测+修复。</p>
<pre tabindex="0"><code>pt-slave-restart --user=dbuser --password=xxxx --socket=/var/lib/mysql/mysql.sock --error-numbers=1032,1677,1051
</code></pre><p>几点说明一下：</p>
<ul>
<li>
<p><code>--sleep</code><br>
pt-slave-restart 循环检查 <code>show slave status</code> 的间隔时间。如果发现有异常，下次sleep time将减半，因为它假设当前有异常，那么下一个event很有可能也异常。</p>
</li>
<li>
<p><code>--master_uuid</code><br>
级联复制下指定了 master_uuid 才能知道事件原始来自于哪里，好让<code>pt-slave-restart</code>知道在哪个 max_trx_id 上面 + 1。</p>
</li>
<li>
<p>在gtid模式下，pt-slave-restart 不能用在多线程复制下（即 <code>slave_parallel_workers&gt;0</code>），因为它不知道这个GTID错误是从库哪个sql线程产生的。</p>
</li>
<li>
<p>以上所有处理错误的方法，在跳过后，都需要进行数据一致性修复(pt-table-sync)，或者重做从库。</p>
</li>
</ul>
<h1 id="6-手动处理复制错误并修复">6. 手动处理复制错误并修复<a hidden class="anchor" aria-hidden="true" href="#6-手动处理复制错误并修复">#</a></h1>
<p>这种处理思路是写程序实现，遇到1032错误，在主库Binlog里面解析出before image，在从库插入，再stop/start slave；遇到1062错误，在从库删除这条数据（可以根据主库binlog after image取数据，也可以根据duplicate key中提示的重复记录），再stop/start/slave。</p>
<p>不需要skip操作，也不需要后续修复数据（只是不会因为有跳过event而产生不一致），如果从主库拿binl log或者从库拿relay log有困难，也可使用 <code>pymysql-replication</code> 来伪装成从库拿到出错的 binlog postion 的内容，解析再用。</p>
<p>当然为保险起见，已经出现不一致的还是要 pt-table-checksum 跑一下。</p>
<h2 id="7-附-测试-slave_skip_errors-slave_exec_mode">7. 附: 测试 slave_skip_errors, slave_exec_mode<a hidden class="anchor" aria-hidden="true" href="#7-附-测试-slave_skip_errors-slave_exec_mode">#</a></h2>
<pre tabindex="0"><code>CREATE TABLE `t_repl_test` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(30) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_name` (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4

insert into t_repl_test values(1,&#39;a&#39;,10), (2,&#39;b&#39;,20), (3,&#39;c&#39;,30), (4,&#39;d&#39;,40),(5,&#39;e&#39;,50);

# 初始化测试数据
# master:
delete from t_repl_test where id=2;

# slave:
delete from t_repl_test where id=3; insert into t_repl_test values(2,&#39;b&#39;,20);
</code></pre><p>每次测试前，数据都初始化成下面的：</p>
<!-- raw HTML omitted -->
<h3 id="71-delete-测试">7.1 delete 测试<a hidden class="anchor" aria-hidden="true" href="#71-delete-测试">#</a></h3>
<p><strong>1. slave_skip_errors=1032,1062</strong><br>
slave:</p>
<pre tabindex="0"><code>mysql&gt; select @@slave_skip_errors, @@slave_exec_mode;
+---------------------+-------------------+
| @@slave_skip_errors | @@slave_exec_mode |
+---------------------+-------------------+
| 1032,1062           | STRICT            |
+---------------------+-------------------+
1 row in set (0.00 sec)
</code></pre><!-- raw HTML omitted -->
<p>mysql&gt; delete from t_repl_test where id in (1,3,4);
Query OK, 3 rows affected (0.00 sec)</p>
<p>mysql&gt; delete from t_repl_test where id in (5);
Query OK, 1 row affected (0.01 sec)</p>
<p>mysql&gt; commit;
Query OK, 0 rows affected (0.00 sec)
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p>在从库，1和5被删除，4被跳过了，<code>skip_error=1032</code>作用在statement上，并且已经部分成功了的statement 不会回滚。</p>
<p><strong>2. slave_exec_mode=IDEMPOTENT</strong><br>
复原。不是设置skip, 设置idempotent， slave:</p>
<pre tabindex="0"><code>mysql&gt; select @@slave_skip_errors, @@slave_exec_mode;
+---------------------+-------------------+
| @@slave_skip_errors | @@slave_exec_mode |
+---------------------+-------------------+
| OFF                 | IDEMPOTENT        |
+---------------------+-------------------+

mysql&gt; select * from t_repl_test;
+----+------+------+
| id | name | age  |
+----+------+------+
|  2 | b    |   20 |
+----+------+------+
</code></pre><p>这次1, 4, 5都被删除，也就是4是一个 statement 里面某一个row_event，没有受到 id=3 error 1032的影响。</p>
<p><strong>注意</strong><br>
如果slave同时设置 slave_skip_errors 和 slave_exec_mode，那么优先生效的是 slave_skip_errors。</p>
<h3 id="72-insert">7.2 insert<a hidden class="anchor" aria-hidden="true" href="#72-insert">#</a></h3>
<p><strong>1. slave_skip_errors=1032,1062 slave_exec_mode=STRICT</strong></p>
<!-- raw HTML omitted -->
<p>mysql&gt; insert into t_repl_test values(8,&lsquo;h&rsquo;,80);
Query OK, 1 row affected (0.01 sec)</p>
<p>mysql&gt; commit;
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p>mysql&gt; select * from t_repl_test;
+&mdash;-+&mdash;&mdash;+&mdash;&mdash;+
| id | name | age  |
+&mdash;-+&mdash;&mdash;+&mdash;&mdash;+
|  1 | a    |   10 |
|  2 | b    |   20 |
|  4 | d    |   40 |
|  5 | e    |   50 |
|  6 | f    |   60 |
|  8 | h    |   80 |
+&mdash;-+&mdash;&mdash;+&mdash;&mdash;+</p>
<!-- raw HTML omitted -->
<p>6成功，2和7失败，8成功。与delete作用范围一致。</p>
<p><strong>2. slave_skip_errors=OFF slave_exec_mode=IDEMPOTENT</strong><br>
slave:</p>
<pre tabindex="0"><code>mysql&gt; select @@slave_skip_errors, @@slave_exec_mode;
+---------------------+-------------------+
| @@slave_skip_errors | @@slave_exec_mode |
+---------------------+-------------------+
| OFF                 | IDEMPOTENT        |
+---------------------+-------------------+

mysql&gt; select * from t_repl_test;
+----+------+------+
| id | name | age  |
+----+------+------+
|  1 | a    |   10 |
|  2 | bb   |  200 |
|  4 | d    |   40 |
|  5 | e    |   50 |
|  6 | f    |   60 |
|  7 | g    |   70 |
|  8 | h    |   80 |
+----+------+------+
</code></pre><p>6, 7, 8 都插入成功，id=2的id=2被更新。所以从库在 idempotent 模式下遇到1062，是replace操作。</p>
<p><strong>3. slave_skip_errors=OFF slave_exec_mode=IDEMPOTENT unique_key</strong><br>
再来看一个好玩的（id是主键，name是唯一索引）: 从库应用relay log遇到 Duplicate entry 错误有不同处理动作。</p>
<!-- raw HTML omitted -->
<p>mysql&gt; insert into t_repl_test values(9,&lsquo;b&rsquo;,200);
Query OK, 1 row affected (0.00 sec)</p>
<p>mysql&gt; update t_repl_test set name=&lsquo;e&rsquo; where id=4;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0</p>
<p>mysql&gt; select * from t_repl_test;
+&mdash;-+&mdash;&mdash;+&mdash;&mdash;+
| id | name | age  |
+&mdash;-+&mdash;&mdash;+&mdash;&mdash;+
|  1 | a    |   10 |
|  3 | c    |   30 |
|  4 | e    |   40 |
|  9 | b    |  200 |
+&mdash;-+&mdash;&mdash;+&mdash;&mdash;+
4 rows in set (0.00 sec)
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p>mysql&gt; select * from t_repl_test;
+&mdash;-+&mdash;&mdash;+&mdash;&mdash;+
| id | name | age  |
+&mdash;-+&mdash;&mdash;+&mdash;&mdash;+
|  1 | a    |   10 |
|  4 | d    |   40 |
|  5 | e    |   50 |
|  9 | b    |  200 |
+&mdash;-+&mdash;&mdash;+&mdash;&mdash;+
4 rows in set (0.00 sec)</p>
<!-- raw HTML omitted -->
<p>第一条 insert 值在从库上 name=b 已经存在，违反唯一约束，所以被 <strong>replace</strong> 掉了。<br>
第二条 update 值在从库上 name=e 已经存在，违反唯一约束，在从库 <strong>被忽略</strong> 了。看从从库的imdepotent错误日志:</p>
<pre tabindex="0"><code>2018-02-02 14:50:35 24325 [Warning] Slave SQL: Could not execute Update_rows event on table d_ec_crmlog.t_repl_test; 
Duplicate entry &#39;e&#39; for key &#39;uk_name&#39;, Error_code: 1062; handler error HA_ERR_FOUND_DUPP_KEY; 
the event&#39;s master log mysql-bin.000015, end_log_pos 27072, Error_code: 1062
</code></pre><p>为什么会有这个行为，可以从源码里面找到答案：</p>
<pre tabindex="0"><code>Write_rows_log_event::do_before_row_operations()
  if ((slave_exec_mode == SLAVE_EXEC_MODE_IDEMPOTENT) ||
      (m_table-&gt;s-&gt;db_type()-&gt;db_type == DB_TYPE_NDBCLUSTER))
  {
    /*
      We are using REPLACE semantics and not INSERT IGNORE semantics
      when writing rows, that is: new rows replace old rows.  We need to
      inform the storage engine that it should use this behaviour.
    */
    
    /* Tell the storage engine that we are using REPLACE semantics. */
    thd-&gt;lex-&gt;duplicates= DUP_REPLACE;
    
    /*
      Pretend we&#39;re executing a REPLACE command: this is needed for
      InnoDB and NDB Cluster since they are not (properly) checking the
      lex-&gt;duplicates flag.
    */
    thd-&gt;lex-&gt;sql_command= SQLCOM_REPLACE;
    /* 
       Do not raise the error flag in case of hitting to an unique attribute
    */
    m_table-&gt;file-&gt;extra(HA_EXTRA_IGNORE_DUP_KEY);

    ...
  }
</code></pre><hr>
<p>本文链接地址：http://xgknight.com/2018/03/11/mysql-replication-error-and-idempotent/</p>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://xgknight.com/tags/mysql/">mysql</a></li>
      <li><a href="http://xgknight.com/tags/replication/">replication</a></li>
    </ul>
  </footer><script src="https://utteranc.es/client.js"
        repo="seanlook/sean-notes-comment"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="http://xgknight.com/">Sean Note</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
