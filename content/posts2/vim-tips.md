---
title: vim编辑器技巧备忘（初级-中级）
date: 2014-08-07 01:21:25
updated: 2014-08-07-12 00:46:23
tags: [vim,编辑器]
categories: Linux
---

“学习vim并且其会成为你最后一个使用的文本编辑器”
学习建议：

- 丢弃鼠标和小键盘
- 具有搭配使用各种按键的意识

首先来一张 [mindmap](http://jrmiii.com/2009/03/06/learning-vim-the-pragmatic-way.html) :

![vim-learn-card][2]

<!-- more -->

# 1. 初级
## 1.1 编辑模式（Insert Mode）
编辑模式包括以下动作：

- insert：`i`在光标所在字符前插入，`I`在当前行首第一个非空格字符前插入
- append：`a`在光标所在字符后插入，`A`在行末尾开始插入
- open：`o`在下一行插入新行，`O`在光标所在行的上一行插入新行
- replace：`r`将光标处字符替换成r紧接的字符；`R`一直替换字符串，知道`ESC`键退出，同windows下的Insert键
- `Ctrl+p`：自动提示
- `[ESC]`：回到普通模式

![vim-mode][1]

## 1.2 普通模式（Normal Mode）

- `h, j, k, l `，分别对应 左←  下↓  上↑  右→ 
- `:q, :q!, :wq`  退出 不保存强行退出 保存退出

- 移动光标到当前行首/非空格，同^，:0
- `$`  移动光标到当前行尾，同:$
- `G`  移动光标到文档最后一行首
- `30G`  转到第30行，同 :30
- `9-`  光标向上移动9行，同9k
- `9+`  光饼向下移动9行，同9[space]，9j

- `gg`  转到文档第一行(1G)
- `H`  移动到屏幕的第一列
- `M`  移动到屏幕的中间列
- `L`  移动到屏幕的最后列

- `w`  移动到下一个单词的首字母，（标点符号认为是一个单词，W表示单词以空格分隔）
- `e`  移动到下一个单词的末尾，（E认为单词以空格分隔）

- `b`  移动到上一个单词的首字母，（B认为单词以空格分隔）
- `fx`  移动到下一个字母是x的位置。Fx向上移动。
- `%`  匹配括号移动，包括 (, {, [ ，你需要把光标先移到括号上

- `CTRL+b` 向上（前）翻页
- `CTRL+f` 向后翻页

- `d`  删除开始。其实是放到寄存器中，p或P命令调用。c即change，删完进入编辑模式
- `d$`  删除光标到行尾的所有文字，同D。C指令进入编辑模式
- `dw`    删除当前字符到单词尾的所有字符。cw删除光标后的单词并进入插入模式，等同替换
- `dd`  删除当前一行
- `2dd`  删除当前两行
- `x`  剪切光标处字符，可以p粘贴出来

- `y`  复制开始。yank起来，p或P命令调用
- `yy p`  复制当前行并粘贴到下一行
- `5yy p` 复制当前行以下5行，在合适的地方粘贴
- `yw p`  复制一个单词并粘贴。
- `yi{`  复制光标所在{}中的内容。很容易知道ci{ 和 di " 的意思。

- `u`      撤销
- `CTRL+r` 重做
- `.`   点号重复做上一个命令
- ``.`  移动光标到上一次的修改点

-  `Ctrl+g` 查看我当前位置

## 1.3 命令模式

- `/word` 向下查找word，n定位到下一个。?word 向上开始查找，同 /word 配合N。* 直接查找光标所在处单词
- `:%s/word1/word2/g`  替换所有 word1 为 word2 (^$ [])
- `:set noic`    区分大小写 (即set no igorecase，set ic不区分大小写)

- `:set nu`  显示行号。:set nonu相反，不显示行号
- `:set paste`  设置为粘贴模式，解决Ctrl+Insert粘贴时缩进错乱问题。:set nopaste设置回默认
- `:se ff=unix` 设置文本文件的格式为unix，去掉windows系统文件中的^M。

- `:!ls`  执行bash下的命令ls，回车后继续回到vi。一般在一个不存在的目录中创建文件时用到
- `:set all` 查看vim说有设置属性值
- `:map` 查看绑定的快捷键
- `:marks` 查看可用标记

熟练上面的命令，已经可以满足日常工作要求，要提高效率可以学习vim的高级用法，如分屏显示、分页、标签功能、代码折叠、键盘映射。

## 1.4 可视化模式
visual mode多用于用键盘灵活选择文本。`v`或`V`键进入，可以实现同时编辑多行（如注释）

# 2. 中级

## 2.1 高级组合命令

- `:sh`   暂时离开vi，进入shell命令行
- `:!ls`  !表示要执行一个shell命令
- `q:`  调出历史命令窗口
- `cc`  替换一行，清空一行
- `cw`  替换一个单词，进入插入模式
- `ea`  在当前单词最后插入

- `vw`  visual模式选择一个单词
- `VU`  全选一行，转换成大写
- `:5,12 co 13` 将5至12行复制到第13行下

- `gg=G` 自动缩排文件
`%` : 匹配括号移动，包括 (, {, [. ，你需要把光标先移到括号上
`*` 和 `#`:匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）
 
当光标在`( )`, `[ ]`,`< >`, `{ }`, `" "`, `''` 内时，可以用`ci`, `di`, 或`yi`，加上`(`, `[`, `<`,`{`, `"`, `'`。这样可以改写/删除/复制`( )`内，`[ ]`内，`< >`内，`{ }`内，`" "`内，`' '`内的内容

**多行注释（块操作）**

1. 首先按`esc`进入命令行模式下，按下`Ctrl + v`，进入列（也叫区块）模式;
2. 在行首使用上下键`kj`选择需要注释的多行;
3. 按下键盘（大写）`I`键，进入插入模式；
4. 然后输入注释符（“//”、“#”等）;
5. 最后按下`esc`键

删除多行开头的一个字符与此类似，删除多个字符也只要左右键，然后使用d。

另外一种多行注释的方式就是替换：

- `:5,9s/^/#/g`    添加注释#
- `:5,9s/^#//g`    删除注释#
- `:5,9s#^#//#g`    添加注释//，同:5,9s/^/\/\/#/g
- `:5,9s#^//##g`    删除注释//

多行缩进
`[ESC]`,  `Ctrl+v`  选择行 <或>左右缩进，=自动缩进（gg=G的局部功能）

多行行末尾加上 >> ${log}：Ctrl+v  /^echo    
`>>`相当于tab键，一个缩进

**多行删除**

1. 首先在命令模式下，输入`set nu`显示行号；
2. 通过行号确定你要删除的行；
3. 命令输入`:32,65d`,回车键，32-65行就被删除了

**自动补全**
在Insert模式下，你可以输入一个词的开头，然后按 `<C-p>`或是`<C-n>`，自动补齐功能就出现了

## 2.2 分屏(split)

分割窗口（同时编辑多个文件）

- `vi -o file1 file2` 水平分屏，也可以在先打开file1后，使用`:sp file2`
- `vi -O file1 file2 `    垂直分屏，也可以在先打开file1后，使用`:vsp file2`
- `Ctrl+w w`  光标切换到另一个屏
- `k`    关闭当前窗口，如果有改动则提示要先保存。`:wqa!`保存退出所有文件
- `Ctrl+w v`  左右分割当前打开的文件。`Ctrl+w s`上下分割显示
- `Ctrl+w H`  左移该屏（大写，`L`右移，`K`上移—改变vertical为horizontal）
- `:set scb`  分屏同步滚动

另外一种不分屏，同时编辑多个文件的方法

`vi file1 file2`
- `:ls `              展示全部打开的文档。其中 `%` 代表正在打开的文件（buffer），`#` 代表上一个编辑过的文件，`a` 代表当前激活的buffer空间，`+` 代表有修改过的内容但还未保存
- `:buffer 2 `   转到打开的第二个文件。或简写为 `:b2`
- `:bn`             转到下一个文件。没有保存不能离开这个文件。`:bp` 上一个文件
- `:b#`             转到上一个编辑过的文件，同 `:e #`。类似于多屏中`Ctrl+w w`
- `:e file3`      编辑一个新的文件 
- `Ctrl+g `       显示当前文件名和行号，同 `:f`

## 2.3 折叠(fold)

主要应用在复杂脚本的场合，特别是函数比较多，逻辑结构比较复杂的代码。（`:help folding`）
有6种方式来折叠代码

1. manual //手工定义折叠
2. indent //用缩进表示折叠
3. expr　 //用表达式来定义折叠
4. syntax //用语法高亮来定义折叠
5. diff   //对没有更改的文本进行折叠
6. marker //用标志折叠

**indent**
`:set foldmethod=indent`    设置缩进折叠，fdm为简写。只对当前会话有效，要使每次打开vim时折叠都生效，则在.vimrc文件中添加设置，如添加：`set fdm=indent`

- `zc`    折叠与当前缩进相同的行
- `zo`    打开折叠
- `zj`    移到下一个折叠处
- `zk`    移到上一个折叠处
- `zm`    折叠所有可折叠标记
- `zr`      展开所有折叠
- `[z`    到当前打开折叠的开始
- `]z`    到当前打开折叠的结束


**marker**
注意与后文的mark不是同一东西，`:set fdm=marker` 

- `zf`    创建marker，默认 `# { { {`, `# } } }`
- `Ctrl+v zf` 进入可视化模式，选择需要折叠的行，zc执行折叠。会自动加入 `# { { {`  code block `# } } }`
- `zf9j`  创建从当前行起至以下9行的折叠标记，`zc`进行折叠。同`9zf`。类似有`zf30G`，从当前行折叠刀第30行
- `zf%`   创建匹配的 `{}`, `[]`, `()`, `<>` 的fold。不用执行`zc`
- `zd`    删除当前行上存在的折叠标记。仅当 'foldmethod' 设为 "manual" 或 "marker" 时有效

## 2.4 标记

标记(mark)是vim提供的精确定位技术，只要你知道标记的名字，就可以使用命令直接跳转到该标记所在的位置。vim中的标记都有一个名字，这个名字用单一的字符表示。大写和小写字母(A-Za-z)都可以做为标记的名字，这些标志的位置可以由用户来设置；而数字标记0-9，以及一些标点符号标记，用户不能进行设置，由vim来自动设置。（:help mark-motions查看更多帮助）

- `ms`    定义一个标记s
- ``s`    跳转到标记s的地方
- `'s`    跳转到调剂s所在行首
- ``.`    jump to position where last change occurred in current buffer
- ``    jump back (to position in current buffer where jumped from)
- `:delmarks aA` 使用 :delmarks! 删除所有小写（a-z）的标记
- `:marks`    查看所有标记

# 3. 插件

待续

# 4. vimrc

[.vimrc][3] 是目前自己用的比较习惯的vim风格。


**参考**

- [简明 Vim 练级攻略](http://coolshell.cn/articles/5426.html)
- [Vim Cheat Sheet for Programmers](http://michael.peopleofhonoronly.com/vim/)
- [VIM哲学](http://segmentfault.com/blog/nightire/1190000000445598)


  [1]: http://github.com/seanlook/sean-notes-comment/raw/main/static/vim-mode.png
  [2]: http://github.com/seanlook/sean-notes-comment/raw/main/static/Vim-mindmap.png
  [3]: http://github.com/seanlook/sean-notes-comment/raw/main/static/vimrc
