<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Virtualization | Sean Note</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="admin">
<link rel="canonical" href="http://xgknight.com/categories/virtualization/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css" integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://xgknight.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://xgknight.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://xgknight.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://xgknight.com/apple-touch-icon.png">
<link rel="mask-icon" href="http://xgknight.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://xgknight.com/categories/virtualization/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Virtualization" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://xgknight.com/categories/virtualization/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Virtualization"/>
<meta name="twitter:description" content=""/>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://xgknight.com/" accesskey="h" title="Sean Note (Alt + H)">Sean Note</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://xgknight.com/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://xgknight.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Virtualization
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>使用vmware vconverter从物理机迁移系统到虚拟机P2V（多图）
    </h2>
  </header>
  <div class="entry-content">
    <p>本文完整记录了如何从物理服务器，保持所有环境配置信息，纹丝不动的迁移到虚拟机上，俗称 P2V 。采用的工具是VMware公司的 VMware vcenter vconverter standalone，它支持将windows和linux操作系统用作源，可以执行若干转换任务：
将正在运行的远程物理机和虚拟机作为虚拟机导入到vCenter Server管理的独立ESX/ESXi或ESX/ESXi主机 将由VMware Workstation或Microsoft Hyper-V Server托管的虚拟机导入到vCenter Server管理的ESX/ESXi主机 将第三方备份或磁盘映像导入到vCenterServer管理的ESX/ESXi主机中 将旧版服务器迁移到新硬件，而不重新安装操作系统或应用程序软件等 完整功能见《Converter Standalone 用户指南》 Converter Standalone的组件，只能安装在Windows操作系统上：
Converter Standalone Server —— 启用并执行虚拟机的导入和导出 Converter Standalone agent —— Converter Standalone Server会在Windows物理机上安装代理，从而将这些物理机作为虚拟机导入，完成后可以选择自动删除 Converter Standalone client —— 与Converter服务端配合使用，包括看到的用户界面、创建和管理转换任务等 Vmware vCenter Converter引导CD：是单独的组件，可用于在物理机上执行冷克隆 冷克隆可以创建一致的源计算机的精确副本，而我们更多的是进行热克隆，也就是源服务器在迁移过程中会继续工作，这就可能会出现某些文件不一致，但Converter Standalone会在热克隆后将目标虚拟机与与主机同步，同步执行过程是将在初始克隆期间更改的块从源复制到目标。
本文记录的过程是，源主机是 SUSE 11.x 物理机，运行华为的智能呼叫中心应用，因此安装有Oracle数据库，对于数据文件和控制文件的一致性和安全性较高，所以建议先把oracle数据库关闭再操作；目标虚拟服务器是 ESXi 5.1，但我使用的Converter是 5.5-en，操作过程类似。下面正式开始
源主机：172.30.31.0/24 ESXi: 172.29.88.0/24，与源主机IP段无法通信 Helper VM: 172.29.41.0/24，与上面两个IP段都通
1. 设置源和目的主机地址 Source System 选择你要转换的源系统，物理机为 Powered-on machine，填写其他登陆信息： Destination System 填写要在哪个主机上创建虚拟机，也就是ESXi服务器地址: 这两个过程有个简短的拉去主机信息的过程。 2. 选择目标虚拟机和存放位置 Destination Virtual Machine 目标虚拟机名字默认是源hostname，不用选择folder： Destination Location...</p>
  </div>
  <footer class="entry-footer"><span title='2015-04-05 15:21:25 +0000 UTC'>April 5, 2015</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to 使用vmware vconverter从物理机迁移系统到虚拟机P2V（多图）" href="http://xgknight.com/posts/2015/04/%E4%BD%BF%E7%94%A8vmware-vconverter%E4%BB%8E%E7%89%A9%E7%90%86%E6%9C%BA%E8%BF%81%E7%A7%BB%E7%B3%BB%E7%BB%9F%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BAp2v%E5%A4%9A%E5%9B%BE/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>在Mac在Mac/win7下上使用Vagrant打造本地开发环境
    </h2>
  </header>
  <div class="entry-content">
    <p>1. vagrant介绍 1.1 vagrant能做什么 做Web开发（java/php/python/ruby…）少不了要在本地搭建好开发环境，虽然说目前各种脚本/语言都有对应的Windows版，甚至是一键安装包，但很多时候和Windows环境的兼容性（如配置文件、编译的模块）并不是那么好，麻烦的问题是实际部署的环境通常是Linux，常常还要面临着开发和部署环境不一致，上线前还要大量的调试。而如果让每个开发人员都自己去搭建本地环境，安装虚拟机、下载ISO镜像、选择规格安装创建vm、安装OS、配置，会耗费非常多的时间，如果是团队开发应该要尽量保持每个人的运行环境一致。此时vagrant正式你所需要的。不适用正式环境部署。
vagrant实际上一套虚拟机管理工具，基于Ruby开发，底层支持VirtualBox、VMware甚至AWS、docker等作为虚拟化系统。我们可以通过 Vagrant 封装一个 Linux 的开发环境，分发给团队成员。成员可以在自己喜欢的桌面系统（Mac/Windows/Linux）上开发程序，代码却能统一在封装好的环境里运行，“代码在我机子上运行没有问题”这种说辞将成为历史。
通过上面的介绍如果你还在困惑有virtualbox或vmware为什么还要加入vagrant，纠结于要不要使用，可以参考这个问答 使用vagrant的意义在哪，另外docker作为后起之秀也可以做vagrant能完成的事情，stackoverflow有关于两位作者讨论各自应用场景的精彩&#34;互掐&#34;，传送门→ （中文）。
1.2 几个概念 Provider：供应商，在这里指Vagrant调用的虚拟化工具。Vagrant本身并没有能力创建虚拟机，它是调用一些虚拟化工具来创建，如VirtualBox、VMWare、Xen、Docker，甚至AWS，这些虚拟化工具只要安装好了，vagrant会自动封装在底层通过统一的命令调用。也就是说使用vagrant时你电脑上还需要安装对应的Provider，默认是免费开源的virtualbox。 Box：可被Vagrant直接使用的虚拟机镜像文件，大小根据内容的不同从200M-2G不等。针对不同的Provider，Box文件的格式是不一样的，从 vagrantcloud.com 你可以找到社区维护的box。
Vagrantfile：Vagrant根据Vagrantfile中的配置来创建虚拟机，是Vagrant的核心。在Vagrantfile文件中你需要指明使用哪个Box（可以下载好的或自己制作，或指定在线的URL地址），虚拟机使用的内存大小和CPU，需要预安装哪些软件，虚拟机的网络配置，与host的共享目录等。
Provisioner：是Vagrant的插件的一种。大部分现成的box并不是你正好想要的，通过使用你熟悉的provisioner，比如Puppet，可以在你使用vagrant up启动虚拟机时自动的安装软件、修改配置等初始化操作。当然你也可以在最先启动虚拟机后，使用vagrant ssh进去然后手动安装软件，但毕竟不是所有人都是系统管理员，写好Vagrantfile后无需人工干预马上就可以使用vm。目前支持并实现的provisioning有Puppet、Salt、Ansible、Chef这些知名的自动化运维工具，当然需要一定的使用经验；也可以使用shell provisioner，故名思议这个插件就是通过执行shell命令完成统一的作用。
Guest Additions：这个是常在下载 base box 介绍里有的，一般用来实现host到vm的端口转发、目录共享，在开发环境上都建议装上以便测试。
2. 安装vagrant VirtualBox: 4.3.12，https://www.virtualbox.org/wiki/Download_Old_Builds_4_3 。我上手使用的是4.3.20，折腾出过几个问题，据说说4.3.12版本较稳定。 建议选择VirtualBox ，即使你电脑上已经安装VMware Workstation或Fushion，它的vagrant插件还是要收费的 Vagrant: 1.7.1，http://www.vagrantup.com/downloads-archive.html 选择适合你的平台（Windows、Mac、Linux），下载对应格式的安装包。如Mac下 vagrant_1.7.1.dmg、VirtualBox-4.3.20-96997-OSX.dmg 。
3. 使用vagrant打造一个本地开发环境 本文将会演示从 nrel CentOS6.5 开始，安装必要的开发包、python、插件、Puppet，然后打包成一个box分发给团队的全过程。你也可以在别人box的基础上进一步通过Vagrantfile定制自己的环境。
3.1 初始化 3.1.1 vagrant box add {box-name} {box-url} $ vagrant box add ct65_00 Downloads/centos65.box ==&gt; box: Adding box &#39;ct65_00&#39; (v0) for provider: box: Downloading: file:///Users/sean/Downloads/centos65....</p>
  </div>
  <footer class="entry-footer"><span title='2015-03-25 11:21:25 +0000 UTC'>March 25, 2015</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to 在Mac在Mac/win7下上使用Vagrant打造本地开发环境" href="http://xgknight.com/posts/2015/03/%E5%9C%A8mac%E5%9C%A8mac/win7%E4%B8%8B%E4%B8%8A%E4%BD%BF%E7%94%A8vagrant%E6%89%93%E9%80%A0%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>在ubuntu上部署Kubernetes管理docker集群示例
    </h2>
  </header>
  <div class="entry-content">
    <p>本文通过实际操作来演示Kubernetes的使用，因为环境有限，集群部署在本地3个ubuntu上，主要包括如下内容：
部署环境介绍，以及Kubernetes集群逻辑架构 安装部署Open vSwitch跨机器容器通信工具 安装部署Etcd和Kubernetes的各大组件 演示Kubernetes管理容器和服务 关于 Kubernetes 系统架构及组件介绍见这里。
1. 部署环境及架构 vSphere: 5.1 操作系统: ubuntu 14.04 x86_64 Open vSwith版本: 2.0.2 Kubernetes: v0.7.2 Etcd版本: 2.0.0-rc.1 Docker版本: 1.4.1 服务器信息： Role Hostname IP Address APIServer kubernetes 172.29.88.206 Minion minion1 172.29.88.207 Minion minion2 172.29.88.208 在详细介绍部署Kubernetes集群前，先给大家展示下集群的逻辑架构。从下图可知，整个系统分为两部分，第一部分是Kubernetes APIServer，是整个系统的核心，承担集群中所有容器的管理工作；第二部分是minion，运行Container Daemon，是所有容器栖息之地，同时在minion上运行Open vSwitch程序，通过GRE Tunnel负责minions之间Pod的网络通信工作。 2. 安装Open vSwitch及配置GRE 为了解决跨minion之间Pod的通信问题，我们在每个minion上安装Open vSwtich，并使用GRE或者VxLAN使得跨机器之间P11od能相互通信，本文使用GRE，而VxLAN通常用在需要隔离的大规模网络中。对于Open vSwitch的介绍请参考另一篇文章Open vSwitch。
sudo apt-get install openvswitch-switch bridge-utils 安装完Open vSwitch和桥接工具后，接下来便建立minion0和minion1之间的隧道。首先在minion1和minion2上分别建立OVS Bridge：
# ovs-vsctl add-br obr0 接下来建立gre，并将新建的gre0添加到obr0，在minion1上执行如下命令：
# ovs-vsctl add-port obr0 gre0 -- set Interface gre0 type=gre options:remote_ip=172....</p>
  </div>
  <footer class="entry-footer"><span title='2015-02-07 13:21:25 +0000 UTC'>February 7, 2015</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to 在ubuntu上部署Kubernetes管理docker集群示例" href="http://xgknight.com/posts/2015/02/%E5%9C%A8ubuntu%E4%B8%8A%E9%83%A8%E7%BD%B2kubernetes%E7%AE%A1%E7%90%86docker%E9%9B%86%E7%BE%A4%E7%A4%BA%E4%BE%8B/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>开源容器集群管理系统Kubernetes架构及组件介绍
    </h2>
  </header>
  <div class="entry-content">
    <p>本文来源于Infoq的一篇文章（见参考部分），并在难懂的地方自己理解的基础上做了修改。实际在ubuntu上部署 kubernetes 操作另见 文章 。
Together we will ensure that Kubernetes is a strong and open container management framework for any application and in any environment, whether in a private, public or hybrid cloud. –Urs Hölzle, Google
Kubernetes 作为Docker生态圈中重要一员，是Google多年大规模容器管理技术的开源版本，是产线实践经验的最佳表现。如Urs Hölzle所说，无论是公有云还是私有云甚至混合云，Kubernetes将作为一个为任何应用，任何环境的容器管理框架无处不在。正因为如此，目前受到各大巨头及初创公司的青睐，如Microsoft、VMWare、Red Hat、CoreOS、Mesos等，纷纷加入给Kubernetes贡献代码。随着Kubernetes社区及各大厂商的不断改进、发展，Kuberentes将成为容器管理领域的领导者。
接下来我们一起探索Kubernetes是什么、能做什么以及怎么做。
1. 什么是Kubernetes Kubernetes是Google开源的容器集群管理系统，使用Golang开发，其提供应用部署、维护、扩展机制等功能，利用Kubernetes能方便地管理跨机器运行容器化的应用，其主要功能如下：
使用Docker对应用程序包装(package)、实例化(instantiate)、运行(run)。 以集群的方式运行、管理跨机器的容器。 解决Docker跨机器容器之间的通讯问题。 Kubernetes的自我修复机制使得容器集群总是运行在用户期望的状态。 当前Kubernetes支持GCE、vShpere、CoreOS、OpenShift、Azure等平台，除此之外，也可以直接运行在物理机上。
这个官方给出的完整的架构图：（可在新标签页打开查看大图）
2. Kubernetes的主要概念 2.1 Pods 在Kubernetes系统中，调度的最小颗粒不是单纯的容器，而是抽象成一个Pod，Pod是一个可以被创建、销毁、调度、管理的最小的部署单元。把相关的一个或多个容器（Container）构成一个Pod，通常Pod里的容器运行相同的应用。Pod包含的容器运行在同一个Minion(Host)上，看作一个统一管理单元，共享相同的volumes和network namespace/IP和Port空间。
2.2 Services Services也是Kubernetes的基本操作单元，是真实应用服务的抽象，每一个服务后面都有很多对应的容器来支持，通过Proxy的port和服务selector决定服务请求传递给后端提供服务的容器，对外表现为一个单一访问地址，外部不需要了解后端如何运行，这给扩展或维护后端带来很大的好处。
这一点github上的官网文档 services.md 讲的特别清楚。
2.3 Replication Controllers Replication Controller，理解成更复杂形式的pods，它确保任何时候Kubernetes集群中有指定数量的pod副本(replicas)在运行，如果少于指定数量的pod副本(replicas)，Replication Controller会启动新的Container，反之会杀死多余的以保证数量不变。Replication Controller使用预先定义的pod模板创建pods，一旦创建成功，pod 模板和创建的pods没有任何关联，可以修改 pod 模板而不会对已创建pods有任何影响，也可以直接更新通过Replication Controller创建的pods。对于利用 pod 模板创建的pods，Replication Controller根据 label selector 来关联，通过修改pods的label可以删除对应的pods。Replication Controller主要有如下用法：...</p>
  </div>
  <footer class="entry-footer"><span title='2015-02-03 13:21:25 +0000 UTC'>February 3, 2015</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to 开源容器集群管理系统Kubernetes架构及组件介绍" href="http://xgknight.com/posts/2015/02/%E5%BC%80%E6%BA%90%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Fkubernetes%E6%9E%B6%E6%9E%84%E5%8F%8A%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Docker集中化web界面管理平台shipyard
    </h2>
  </header>
  <div class="entry-content">
    <p>Shipyard（github）是建立在docker集群管理工具Citadel之上的可以管理容器、主机等资源的web图形化工具。包括core和extension两个版本，core即shipyard主要是把多个 Docker host上的 containers 统一管理（支持跨越多个host），extension即shipyard-extensions添加了应用路由和负载均衡、集中化日志、部署等。
1. 几个概念 engine 一个shipyard管理的docker集群可以包含一个或多个engine（引擎），一个engine就是监听tcp端口的docker daemon。shipyard管理docker daemon、images、containers完全基于Docker API，不需要做其他的修改。另外，shipyard可以对每个engine做资源限制，包括CPU和内存；因为TCP监听相比Unix socket方式会有一定的安全隐患，所以shipyard还支持通过SSL证书与docker后台进程安全通信。
rethinkdb RethinkDB是一个shipyard项目的一个docker镜像，用来存放账号（account）、引擎（engine）、服务密钥（service key）、扩展元数据（extension metadata）等信息，但不会存储任何有关容器或镜像的内容。一般会启动一个shipyard/rethinkdb容器shipyard-rethinkdb-data来使用它的/data作为数据卷供另外rethinkdb一个挂载，专门用于数据存储。
2. 搭建过程 修改tcp监听 Shipyard 要管理和控制 Docker host 的话需要先修改 Docker host 上的默认配置使其监听tcp端口(可以继续保持Unix socket）。有以下2种方式
sudo docker -H tcp://0.0.0.0:4243 -H unix:///var/run/docker.sock -d 启动docker daemon。如果为了避免每次启动都写这么长的命令，可以直接在/etc/init/docker.conf中修改。 修改/etc/default/docker的DOCKER_OPTS DOCKER_OPTS=&#34;-H tcp://127.0.0.1:4243 -H unix:///var/run/docker.sock&#34;。这种方式在我docker version 1.4.1 in ubuntu 14.04上并没有生效。 重启服务 $ sudo docker -H tcp://0.0.0.0:4243 -H unix:///var/run/docker.sock -d 验证 $ netstat -ant |grep 4243 tcp6 0 0 :::4243 :::* LISTEN 启动rethinkdb shipyard（基于Python/Django）在v1版本时安装过程比较复杂，既可以通过在host上安装，也可以部署shipyard镜像（包括shipyard-agent、shipyard-deploy等组件）。v2版本简化了安装过程，启动两个镜像就完成：...</p>
  </div>
  <footer class="entry-footer"><span title='2014-12-29 13:21:25 +0000 UTC'>December 29, 2014</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to Docker集中化web界面管理平台shipyard" href="http://xgknight.com/posts/2014/12/docker%E9%9B%86%E4%B8%AD%E5%8C%96web%E7%95%8C%E9%9D%A2%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0shipyard/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>【转&#43;改】Docker核心技术预览
    </h2>
  </header>
  <div class="entry-content">
    <p>本文简单介绍docker使用到的部分核心技术，但不做深入探究，因为每一个技术都是一个独立的项目，有机会再分别详细介绍。 来源地址：http://www.infoq.com/cn/articles/docker-core-technology-preview
Linux Namespace （实例隔离）## The purpose of each namespace is to wrap a particular global system resource in an abstraction that makes it appear to the processes within the namespace that they have their own isolated instance of the global resource.
每个用户实例之间相互隔离，互不影响。一般的硬件虚拟化方法给出的方法是VM，而LXC给出的方法是container，更细一点讲就是kernel namespace。其中pid、net、ipc、mnt、uts、user等namespace将container的进程、网络、消息、文件系统、UTS(“UNIX Time-sharing System”)和用户空间隔离开。
pid namespace 不同用户的进程就是通过pid namespace隔离开的，且不同 namespace 中可以有相同pid。所有的LXC进程在docker中的父进程为docker进程，每个lxc进程具有不同的namespace。同时由于允许嵌套，因此可以很方便的实现 Docker in Docker。
** net namespace ** 有了 pid namespace, 每个namespace中的pid能够相互隔离，但是网络端口还是共享host的端口。网络隔离是通过net namespace实现的， 每个net namespace有独立的 network devices, IP addresses, IP routing tables, /proc/net 目录。这样每个container的网络就能隔离开来。LXC在此基础上有5种网络类型，docker默认采用veth的方式将container中的虚拟网卡同host上的一个docker bridge—docker0连接在一起。...</p>
  </div>
  <footer class="entry-footer"><span title='2014-12-18 13:21:25 +0000 UTC'>December 18, 2014</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to 【转&#43;改】Docker核心技术预览" href="http://xgknight.com/posts/2014/12/%E8%BD%AC-%E6%94%B9docker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E9%A2%84%E8%A7%88/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Docker简介
    </h2>
  </header>
  <div class="entry-content">
    <p>1. docker是什么 Docker is an open-source engine that automates the deployment of any application as a lightweight, portable, self-sufficient container that will run virtually anywhere.
Docker是 PaaS 提供商dotCloud开源的一个基于 LXC 的高级容器引擎， 源代码托管在 Github 上, 基于go语言并遵从Apache2.0协议开源。Docker近期非常火热，无论是从 GitHub 上的代码活跃度，还是Redhat宣布在RHEL7中正式支持Docker，都给业界一个信号，这是一项创新型的技术解决方案。就连 Google 公司的 Compute Engine 也支持 docker 在其之上运行，国内“BAT”先锋企业百度Baidu App Engine(BAE)平台也是以Docker作为其PaaS云基础。
Docker产生的目的就是为了解决以下问题：
环境管理复杂：从各种OS到各种中间件再到各种App，一款产品能够成功发布，作为开发者需要关心的东西太多，且难于管理，这个问题在软件行业中普遍存在并需要直接面对。Docker可以简化部署多种应用实例工作，比如Web应用、后台应用、数据库应用、大数据应用比如Hadoop集群、消息队列等等都可以打包成一个Image部署。 云计算时代的到来：AWS的成功，引导开发者将应用转移到云上, 解决了硬件管理的问题，然而软件配置和管理相关的问题依然存在 (AWS cloudformation是这个方向的业界标准, 样例模板可参考这里)。Docker的出现正好能帮助软件开发者开阔思路，尝试新的软件管理方法来解决这个问题。 虚拟化手段的变化：云时代采用标配硬件来降低成本，采用虚拟化手段来满足用户按需分配的资源需求以及保证可用性和隔离性。然而无论是KVM还是Xen，在 Docker 看来都在浪费资源，因为用户需要的是高效运行环境而非OS，GuestOS既浪费资源又难于管理，更加轻量级的LXC更加灵活和快速。 LXC的便携性：LXC在 Linux 2.6 的 Kernel 里就已经存在了，但是其设计之初并非为云计算考虑的，缺少标准化的描述手段和容器的可便携性，决定其构建出的环境难于分发和标准化管理(相对于KVM之类image和snapshot的概念)。Docker就在这个问题上做出了实质性的创新方法。 Docker的主要特性如下：
文件系统隔离：每个进程容器运行在完全独立的根文件系统里。 资源隔离：可以使用cgroup为每个进程容器分配不同的系统资源，例如CPU和内存。 网络隔离：每个进程容器运行在自己的网络命名空间里，拥有自己的虚拟接口和IP地址。 写时复制：采用写时复制方式创建根文件系统，这让部署变得极其快捷，并且节省内存和硬盘空间。 日志记录：Docker将会收集和记录每个进程容器的标准流（stdout/stderr/stdin），用于实时检索或批量检索。 变更管理：容器文件系统的变更可以提交到新的映像中，并可重复使用以创建更多的容器。无需使用模板或手动配置。 交互式Shell：Docker可以分配一个虚拟终端并关联到任何容器的标准输入上，例如运行一个一次性交互shell。 2. 比较 2....</p>
  </div>
  <footer class="entry-footer"><span title='2014-12-18 11:21:25 +0000 UTC'>December 18, 2014</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to Docker简介" href="http://xgknight.com/posts/2014/12/docker%E7%AE%80%E4%BB%8B/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Dockerfile指令详解
    </h2>
  </header>
  <div class="entry-content">
    <p>Docker可以从Dockerfile中一步一步的读取指令来自动的创建镜像，常使用Dockerfile来创建用户自定义的镜像。格式如下：
# Comment INSTRUCTION arguments 虽然前面的指令大小写不敏感，但习惯性的还是建议大写。docker是严格按照顺序（#注释起来的忽略）运行指令的。 下面逐个来介绍几个必要的指令。
FROM FROM &lt;image&gt; 或 FROM &lt;image&gt;:&lt;tag&gt; 在Dockerfile中第一条非注释INSTRUCTION一定是FROM，它决定了以哪一个镜像作为基准，&lt;image&gt;首选本地是否存在，如果不存在则会从公共仓库下载（当然也可以使用私有仓库的格式）。
RUN RUN &lt;commnad&gt; 或 RUN [&#34;executable&#34;, &#34;param1&#34;, &#34;param2&#34;] RUN指令会在当前镜像的顶层执行任何命令，并commit成新的（中间）镜像，提交的镜像会在后面继续用到。 上面看到RUN后的格式有两种写法。
shell格式，相当于执行/bin/sh -c &#34;&lt;command&gt;&#34;：
RUN apt-get install vim -y exec格式，不会触发shell，所以$HOME这样的环境变量无法使用，但它可以在没有bash的镜像中执行，而且可以避免错误的解析命令字符串：
RUN [&#34;apt-get&#34;, &#34;install&#34;, &#34;vim&#34;, &#34;-y&#34;] 或 RUN [&#34;/bin/bash&#34;, &#34;-c&#34;, &#34;apt-get install vim -y&#34;] 与shell风格相同 ENTRYPOINT ENTRYPOINT命令设置在容器启动时执行命令，如果有多个ENTRYPOINT指令，那只有最后一个生效。有以下两种命令格式：
ENTRYPOINT [&#34;executable&#34;, &#34;param1&#34;, &#34;param2&#34;] 数组/exec格式，推荐 或 ENTRYPOINT command param1 param2 shell格式 比如：
docker run -i -t --rm -p 80:80 nginx 使用exec格式，在docker run &lt;image&gt;的所有参数，都会追加到ENTRYPOINT之后，并且会覆盖CMD所指定的参数（如果有的话）。当然可以在run时使用--entrypoint来覆盖ENTRYPOINT指令。 使用shell格式，ENTRYPOINT相当于执行/bin/sh -c &lt;command....</p>
  </div>
  <footer class="entry-footer"><span title='2014-11-17 15:21:25 +0000 UTC'>November 17, 2014</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to Dockerfile指令详解" href="http://xgknight.com/posts/2014/11/dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>搭建docker内网私服（docker-registry with nginx&amp;ssl on centos）
    </h2>
  </header>
  <div class="entry-content">
    <p>主要思路： 1. Docker Registry 说明 关于如何创建和使用本地仓库，其实已经有很多文章介绍了。因为docker技术正处于发展和完善阶段，所以有些文章要么内容已经过时，要么给出了错误的配置，导致无法正常创建仓库。本文记录的是个人完整的搭建过程，docker version为1.1.2。
官方提供了Docker Hub网站来作为一个公开的集中仓库。然而，本地访问Docker Hub速度往往很慢，并且很多时候我们需要一个本地的私有仓库只供网内使用。
Docker仓库实际上提供两方面的功能，一个是镜像管理，一个是认证。前者主要由docker-registry项目来实现，通过http服务来上传下载；后者可以通过docker-index（闭源）项目或者利用现成认证方案（如nginx）实现http请求管理。
docker-registry既然也是软件应用，自然最简单的方法就是使用官方提供的已经部署好的镜像registry。官方文档中也给出了建议，直接运行sudo docker run -p 5000:5000 registry命令。这样确实能启动一个registry服务器，但是所有上传的镜像其实都是由docker容器管理，放在了/var/lib/docker/….某个目录下。而且一旦删除容器，镜像也会被删除。因此，我们需要想办法告诉docker容器镜像应该存放在哪里。registry镜像中启动后镜像默认位置是/tmp/registry，因此直接映射这个位置即可，比如到本机的/opt/data/registry目录下。
2. 在CentOS上搭建docker私服 2.1 安装docker-registry 方法有多种，直接运行下面的命令：
# docker run -d -e SETTINGS_FLAVOR=dev -e STORAGE_PATH=/tmp/registry -v /opt/data/registry:/tmp/registry -p 5000:5000 registry 如果本地没有拉取过docker-registry，则首次运行会pull registry，运行时会映射路径和端口，以后就可以从/opt/data/registry下找到私有仓库都存在哪些镜像，通过主机的哪个端口可以访问。 你也可以把项目 https://github.com/docker/docker-registry.git 克隆到本地，然后使用Dockerfile来build镜像：
# git clone https://github.com/docker/docker-registry.git # cd docker-registry &amp;&amp; mkdir -p /opt/data/registry # docker build -t &#34;local-sean&#34; . build完成后，就可以运行这个docker-registry 我们先配置自己的config.yml文件，第一种方法是直接在run的时候指定变量 # cp config/config_sample.yml /opt/data/registry/config.yml # vi /opt/data/registry/config.yml ##这里可以设置本地存储SETTINGS_FLAVOR=dev，local STORAGE_PATH:/tmp/registry等待 # docker run -d -v /opt/data/registry:/tmp/registry -p 5000:5000 -e DOCKER_REGISTRY_CONFIG=/tmp/registry/config....</p>
  </div>
  <footer class="entry-footer"><span title='2014-11-13 20:21:25 +0000 UTC'>November 13, 2014</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to 搭建docker内网私服（docker-registry with nginx&amp;ssl on centos）" href="http://xgknight.com/posts/2014/11/%E6%90%AD%E5%BB%BAdocker%E5%86%85%E7%BD%91%E7%A7%81%E6%9C%8Ddocker-registry-with-nginxssl-on-centos/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>docker常用管理命令（下）
    </h2>
  </header>
  <div class="entry-content">
    <p>本文承接docker专题(2)：docker常用管理命令（上）。
1. 开启/停止/重启container（start/stop/restart） 容器可以通过run新建一个来运行，也可以重新start已经停止的container，但start不能够再指定容器启动时运行的指令，因为docker只能有一个前台进程。 容器stop（或Ctrl&#43;D）时，会在保存当前容器的状态之后退出，下次start时保有上次关闭时更改。而且每次进入attach进去的界面是一样的，与第一次run启动或commit提交的时刻相同。
CONTAINER_ID=$(docker start &lt;containner_id&gt;) docker stop $CONTAINER_ID docker restart $CONTAINER_ID 关于这几个命令可以通过一个完整的实例使用：docker如何创建一个运行后台进程的容器并同时提供shell终端。
2. 连接到正在运行中的container（attach） 要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。 官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上 --sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。
# docker attach --sig-proxy=false $CONTAINER_ID 3. 查看image或container的底层信息（inspect） inspect的对象可以是image、运行中的container和停止的container。
查看容器的内部IP # docker inspect --format=&#39;{\{.NetworkSettings.IPAddress}}&#39; $CONTAINER_ID 172.17.42.35 （注：由于代码块解析的问题，上面NetworkSettings前面的 \ 去掉） 4. 删除一个或多个container、image（rm、rmi） 你可能在使用过程中会build或commit许多镜像，无用的镜像需要删除。但删除这些镜像是有一些条件的：
同一个IMAGE ID可能会有多个TAG（可能还在不同的仓库），首先你要根据这些 image names 来删除标签，当删除最后一个tag的时候就会自动删除镜像； 承上，如果要删除的多个IMAGE NAME在同一个REPOSITORY，可以通过docker rmi &lt;image_id&gt;来同时删除剩下的TAG；若在不同Repo则还是需要手动逐个删除TAG； 还存在由这个镜像启动的container时（即便已经停止），也无法删除镜像； TO-DO 如何查看镜像与容器的依存关系
** 删除容器 ** docker rm &lt;container_id/contaner_name&gt;
删除所有停止的容器 docker rm $(docker ps -a -q) ** 删除镜像 ** docker rmi &lt;image_id/image_name ....</p>
  </div>
  <footer class="entry-footer"><span title='2014-11-05 16:21:25 +0000 UTC'>November 5, 2014</span>&nbsp;·&nbsp;admin</footer>
  <a class="entry-link" aria-label="post link to docker常用管理命令（下）" href="http://xgknight.com/posts/2014/11/docker%E5%B8%B8%E7%94%A8%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E4%B8%8B/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="http://xgknight.com/categories/virtualization/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="http://xgknight.com/">Sean Note</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
